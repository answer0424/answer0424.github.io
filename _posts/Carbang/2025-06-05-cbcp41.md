---
layout: post
title: git action
date: 2025-06-05  09:00 +09:00
categoties: [cbcp, week10]
tags: [cbcp]
---

## 1. Github Actions 이해

<br>

## 개요

- GitHub Actions는 Github의 CI/CD 자동화 플랫폼
- 코드의 빌드, 테스트, 배포 작업을 자동화 가능
- 풀 리퀘스트 생성, 병합, 이슈 등록 등 다양한 이벤트에 따라 워크플로 실행 가능
- GitHub이 제공하는 Linux, Windows, macOS 가상 머신에서 실행
- 사용자가 직접 설정한 자체 호스트 러너에서도 실행 가능

<br>

## 구성요소

<br>

#### 워크플로

> 하나 이상의 작업을 실행할 구성 가능한 자동화 프로세스
>
> 리포지토리에 체크된 YAML 파일에서 정의되며, 리포지토리의 이벤트로 트리거될 때 실행되거나 수동으로 또는 정의된 일정에 따라 트리거

- 워크플로는 리포지토리의 `.github/workflows` 디렉터리에 정의 
  - 끌어오기 요청을 빌드하고 테스트
  - 릴리스가 생성될 때마다 애플리케이션을 배포
  - 새 문제가 보고될 때마다 레이블을 추가

<br>

#### 이벤트

> 워크플로 실행을 트리거하는 리포지토리의 특정 활동

<br>

#### 작업

> 동일한 실행에서 실행되는 워크플로의 단계 집합

- 각 단계는 실행되는 셸 스크립트 또는 실행되는 `작업`
- 단계는 순서대로 실행되며 서로 종속
- 각 단계는 동일한 실행기에서 실행되므로 단계 간에 데이터를 공유할 수 있음
- 작업 간 종속성을 구성할 수 있음
  - 기본적으로 작업은 종속성이 없으며 병렬로 실행
  - 작업이 다른 작업에 종속될 경우 해당 작업이 끝나기 전까지 대기(Thread)

<br>

#### 실행기

> 트리거될 때 워크플로를 실행하는 서버

- 각 실행자는 한 번에 하나의 작업을 실행 가능
- 이때 실행할 Ubunutu Linux, Microsoft Windows, macOS 실행기를 제공
- 각 워크플로 실행은 새로 프로비저닝된 새 가상 머신에서 실행
- 다른 운영 체제가 필요하거나 특정 하드웨어 구성이 필요한 경우 자체 실행기 호스트 가능

<br>

## 2. 워크플로에서 미리 작성된 구성 요소 사용

<br>

## 개요

> 워크플로에서 미리 작성된 구성 요소인 작업을 사용할 수 있음
> 
> 작업은 워크 플로 내에서 특정 작업을 수행하는 미리 정의되고 재사용 가능한 작업 또는 코드 집합

- 재사용 가능: 여러 워크플로 및 저장소에서 작업을 사용할 수 있으므로 동일한 코드를 다시 작성할 필요가 없음
- 미리 작성된: GitHub Marketplace에는 코드 체크아웃, 환경 설정, 테스트 실행, 애플리케이션 배포 등 광범위한 작업을 포괄하는 많은 작업이 제공
- 구성 가능: 입력, 출력 및 환경 변수를 사용하여 작업을 구성하여 특정 요구 사항에 맞게 조정 가능
- 커뮤니티 중심: 직접 액션을 만들어 다른 사람과 고유 가능

- 워크플로에서 사용하는 작업
  - 워크플로 파일과 동일한 저장소
  - 모든 공개 저장소
  - Docker Hub에 게시된 Docker 컨테이너 이미지

<br>

## 워크플로 편집기에서 마켓플레이스 작업 탐색

> 사이드바에서 특정 작업을 검색하고, 추천 작업을 보고, 추천 카테고리를 찾아볼 수 있음

- 저장소에서 편집하려는 워크플로 파일을 찾기
- 파일 보기의 오른쪽 상단 모서리에서 워크 플로 편집기 클릭
- 편집기 오른쪽의 사이드바를 사용하여 액션을 탐색

<br>

## 워크플로에 작업 추가

> 워크플로에서 참조되는 작업은 워크플로가 포함된 저장소의 종속성 그래프에서 종속성을 확인 가능

<br>

#### GitHub Marketplace에서 작업 추가

> 액션 목록 페이지에는 액션 버전과 액션 사용에 필요한 워크플로 구문이 포함

- 워크플로에서 사용할 작업으로 이동
- 해당 작업에 대한 전체 마켓플레이스 목록 클릭
- 설치에서 워크플로 구문을 복사
- 워크플로에 구문을 붙여넣기
- 작업에 입력이 필요한 경우 워크플로에서 입력을 설정

<br>

#### 동일한 저장소에서 작업 추가

> 워크플로 파일에서 작업을 사용하는 동일한 저장소에 작업이 정의된 경우 워크플로 파일에서 `{owner}/{repo}@{ref}` 또는 구문을 사용하여 해당 작업을 참조 가능 `./path/to.dir`

- 예시 저장소 파일 구조

```ini
|-- hello-world (repository)
|   |__ .github
|       └── workflows
|           └── my-first-workflow.yml
|       └── actions
|           |__ hello-world-action
|               └── action.yml
```

- 경로는 `./` 기본 작업 디렉터리 (`github.workspace`, `$GITHUB_WORKSPACE`)를 기준으로 상대 경로
- 워크플로 파일의 예

```yaml
jobs:
    my_first_job:
        runs_on: ubunutu-latest
        steps:
            # This step check out a copy of your repository
            - name: My first step - check out repository
              uses: actions/checkout@v4
            # This step references the directory that contains the action
            - name: Use local hello-world-action
              uses: ./.github/actions/hellow-world-action
```

<br>

#### 다른 저장소에서 작업 추가

> 작업이 워크플로 파일과 다른 저장소에 정의된 경우 `{owner}/{repo}@{ref}` 워크플로 파일의 구문을 사용하여 해당 작업 참조

```yaml
jobs:
    my_first_job:
        step:
            - name: My first step
              uses: actions/setup-node@v4
```

<br>

#### Docker Hub에서 컨테이너 참조

> Docker Hub에 게시된 Docker 컨테이너 이미지에 작업이 정의된 경우, `docker://{image}:{tag}` 워크플로 파일의 구문을 사용하여 해당 작업을 참조해야 함

```yaml
jobs:
    my_first_job:
        steps:
            - name: My first step
              uses: docker://alpine:3.8
```

<br>

## 워크플로에서 작업을 사용하기 위한 보안 강화

> Github는 워크플로 보안을 강화하는 데 사용할 수 있는 보안 기능을 제공

<br>

## 사용자 정의 작업에 대한 릴리스 관리 사용

> 커뮤니티 액션 생성자는 태그, 브랜치 또는 SHA 값을 사용하여 액션 릴리스를 관리할 수 있음
>
> 다른 종속성과 마찬가지로 액션 업데이트를 자동으로 수락하는 것에 대한 사용자의 선호도에 따라 사용할 액션 버전을 지정해야 함

<br>

#### 태그 사용

- 태그는 주요 버전과 부 버전간 전환 시점을 결정하는 데 유용하지만, 임시적이며 유지 관리자가 이동하거나 삭제할 수 있음

```yaml
steps:
    - uses: actions/javascript-action@v1.0.1
```

<br>

#### SHA 사용

- 더 안정적인 버전 관리가 필요한 경우, 작업 버전과 연결된 SHA 값을 사용해야 함
- 하지만 이 방법은 중요한 버그 수정 및 보안 업데이트를 포함한 작업 업데이트를 자동으로 받을 수 없음

```yaml
steps:
    - uses: actions/javascript-action@a824008085750b8e136effc585c3cd6082bd575f
```

<br>

#### 브랜치 사용

- 작업에 대상 브랜치를 지정하면 항상 해당 브랜치의 현재 버전이 실행
- 해당 방식은 브랜치 업데이트에 호환성이 손상되는 변경 사항이 포함된 경우 문자가 발생할 수 있음

```yaml
steps:
    - uses: actions/javascript-action@main
```

<br>

## 동작과 함께 입력 및 출력 사용

> 액션은 입력을 받거나 요구하고, 사용자가 사용할 수 있는 출력을 생성
>
> 동작의 입력과 출력을 보기 위해서 `action.yml` 저장소의 루트 디렉토리 확인 가능

```yaml
name: "Example"
description: "Receives file and generates output"
inputs: 
    file-path:  # id of input
        description: "Path to test script"
        required: true
        default: "test-file.js"
outputs:
    results-file:   # id of output
        description: "Path to results file"
```

<br>

## 워크플로 정보

> 워크플로는 하나 이상의 작업을 실행할 구성 가능한 자동화된 프로세스
>
> 워크플로는 리포지토리에 체크인된 YAML 파일에서 정의되며, 리포지토리의 이벤트로 트리거될 때 실행되거나 수동으로 또는 정의된 일정에 따라 트리거 가능

- 리포지토리의 `.github/workflows` 디렉터리에 정의
  - 풀 리퀘스트를 빌드하고 테스트
  - 릴리스가 생성될 때마다 애플리케이션을 배포
  - 새문자가 보고될 때마다 레이블을 추가

<br>

## 워크플로 기본 사항

- 워크플로를 트리거하는 하나 이상의 이벤트
- 하나 이상의 _작업_이며 각 작업은 실행기 머신에서 실행되고 일련의 하나 이상의 _단계_를 실행
- 각 단계에서는 워크플로를 간소화할 수 있는 재사용 가능한 확장인 작업을 정의하거나 실행하는 스크립트를 실행 가능

<br>

## 워크플로 트리거

> 워크플로 트리거는 워크플로를 실행하게 하는 이벤트

- 워크플로의 리포지토리에서 발생하는 이벤트
- GitHub 외부에서 발생하고 GitHub에서 `repository_dispatch` 이벤트를 트리거하는 이벤트
- 예약된 시간
- description 

<br>

## 워크플로 구문

- 워크플로는 YAML을 사용하여 정의

<br>

## 워크플로 템플릿 사용

> GitHub는 미리 구성된 워크플로 템플릿을 제공하며, 이를 그대로 사용하거나 사용자 지정하여 자신만의 워크플로를 만들 수 있음
>
> GitHub는 코드를 분석하여 리포지토리에 유용할 수 있는 워크플로 템플릿을 보여줌
>
> 이러한 워크플로 템플릿은 빠르게 시작하여 실행할 수 있도록 설계되어 있음

- CI: [연속 통합 워크플로](https://github.com/actions/starter-workflows/tree/main/ci)
- 배포: [배포 워크플로](https://github.com/actions/starter-workflows/tree/main/deployments)
- 자동화: [워크플로 자동화](https://github.com/actions/starter-workflows/tree/main/automation)
- 코드 검사: [코드 검사 워크플로](https://github.com/actions/starter-workflows/tree/main/code-scanning)
- 페이지: [페이지 워크플로](https://github.com/actions/starter-workflows/tree/main/pages)

<br>

## 고급 워크플로 기능

> 해당 섹션에서는 더 복잡한 워크플로를 만드는 데 도움이 되는 GitHub Actions의 고급 기능 중 일부

<br>

#### 비밀 저장

> 워크플로에서 암호 또는 인증서와 같은 중요한 데이터를 사용하는 경우 GitHub에 비밀로 저장한 다음 워크플로에서 환경 변수로 사용 가능

```yaml
jobs:
    example-job:
        runs-on: ubuntu-latest
        steps:
            - name: Retrieve secret
              env:
                super_secret: ${{ secrets.SUPERSECRET }}
            run: |
                example-command "$super_secret"
```

<br>

#### 종속 작업 만들기

> 워크플로의 작업은 모두 동시에 병렬로 실행
>
> 다른 작업이 와나료된 후에만에 실행해야 하는 작업이 있는 경우 `needs` 키워드를 사용하여 이 종속성을 만들 수 있음
>
> 작업 중 하나가 실패할 경우 모든 종속 작업은 skip
>
> 그러나 작업을 계속해야 하는 경우 `if` 조건문을 사용하여 이를 정의 할 수 있음

```yaml
jobs:
    setup:
        runs-on: ubuntu-latest
        steps:
            - run: ./setup_server.sh
    build:
        needs: setup
        runs-on: ubuntu-latest
        steps:
            - run: ./build_server.sh
    test:
        needs: build
        runs-on: ubuntu-latest
        steps:
            - run: ./test_server.sh
```

<br>

#### 매트릭스 사용

> 매트릭스 전략을 사용하면 단일 작업 정의에서 변수를 사용하여 변수의 조합을 기반으로 하는 여러 작업 실행을 자동으로 만들 수 있음
>
> 매트릭스는 빌드 옵션을 배열로 수신하는 `strategy` 키워드를 사용하여 만들어짐

```yaml
jobs:
    build:
        runs-on: ubuntu-latest
        strategy:
            matrix:
                node: [14, 16]
        steps:
            - uses: actions/setup-node@v4
              with:
                node-version: ${{ matrix.node }}
```

<br>

## 종속성 캐싱

> 작업에서 종속성을 정기적으로 다시 사용하는 경우 이러한 파일을 캐싱하여 성능을 개선

- 아래는 `./npm` 디렉터리를 캐싱하는 방법

```yaml
jobs:
    example-job:
        steps:
            - name: Cache node modules
              uses: actions/cache@v4
              env:
                cache-name: cache-node-modules
              with:
                path: ~/.nppm
                key: ${{ runner.os }}-build-${{ env.cache-name }}-${{ hashFiles('**/package-lock.json') }}
                restore-keys: |
                    ${{ runner.os }}-build-${{ env.cache-name }}-
```

<br>

