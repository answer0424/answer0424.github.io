---
layout: post
title: 26. 소프트웨어 아키텍처
date: 2026-02-01 09:00 +09:00
categories: [IEIP, Subject 1]
tags: [IEIP]
---

## 소프트웨어 아키텍처의 설계

> 소프트웨어 아키텍처는 소프트웨어의 골격이 되는 기본 구조이자, 소프트웨어를 구성하는 요소들 간의 관계를 표현하는 시스템의 구조 또는 구조체

- 소프트웨어 개발 시 적용되는 원칙과 지침
- 이해하기 쉽고 명확하게 작성되어야 함
- 좋은 품질을 유지하며, 사용자의 비기능적 요구사항으로 나타난 제약을 반영하고, 기능적 요구사항을 구현하는 방법을 찾는 해결 과정
- 설계의 기본 원리로는 모듈화, 추상화, 단계적 분해, 정보 은닉이 있음

<hr>

## 소프트웨어 아키텍처 뷰(View)

#### 유스케이스(Use Case) 뷰

- 시스템 외부 사용자의 관점에서 사용 사례와 이들간의 관계를 정의하며, 다른 뷰를 검증하는 용도로 사용

<br>

#### 논리적 (Logical) 뷰

- 설계자 관점에서 시스템의 기능적인 요구사항이 제공되는 방법을 설명해줌

<br>

#### 구현(Implementation) 뷰

- 개발자의 관점에서 서브 시스템 모듈이 어떻게 구조화되어 있는지 확인하기 위해 소프트웨어 구성을 보여줌

<br>

#### 프로세스(Process) 뷰

- 시스템 통합자의 관점에서 자원의 효율적인 사용, 이벤트 처리등을 표현함

<br>

#### 배포(Deployment) 뷰

- 테스터의 관점에서 컴포넌트가 어떻게 배치되고 연결되는지를 보여줌

<hr>

## 모듈화(Modularity)

> 소프트웨어의 성능을 향상시키거나 시스템의 수정 및 재사용, 유지 관리등이 용이하도록 시스템의 기능을 모듈 단위로 나누는 것을 말함

- 자주 사용되는 계산식이나 사용자 인증과 같은 기능들을 공통 모듈로 구성하여 프로젝트의 재사용성을 향상시킬 수 있음
- 모듈의 크기를 너무 작게 나누면 개수가 많아져 모듈 간의 통합 비용이 많이 들고, 너무 크게 나누면 개수가 적어 통합 비용이 적게 들지만 모듈 하나의 개발 비용이 많이 듦

<hr>

## 추상화(Abstraction)

> 문제의 전체적이고 포괄적인 개념을 설계한 후 차례로 세분화하여 구체화 시켜 나가는 것

- 완전한 시스템을 구축하기 전에 그 시스템과 유사한 모델을 만들어서 여러 가지 요인들을 테스트할 수 있음
- 추상화는 최소의 비용으로 실제 상화에 대처할 수 있고, 시스템의 구조 및 구성을 대략적으로 파악할 수 있게 해줌

- 추상화의 유형
    - 과정 추상화: 자세한 수행과정을 정의하지 않고, 전반적인 흐름만 파악할 수 있게 설계하는 방법
    - 데이터 추상화: 데이터의 세부적인 속성이나 용도를 정의하지 않고 데이터 구조를 대표할 수 있는 표현으로 대체하는 방법
    - 제어 추상화: 이벤트 발생의 정확한 절차나 방법을 정의하지 않고, 대표할 수 있는 표현으로 대체하는 방법

<hr>

## 단계적 분해(Stepwise Refinement)

> 하향식 설계 전략으로, 문제를 상위의 중요 개념으로 구체화시키는 분할 기법

- 추상화의 반복에 의해 세분화됨
- 소프트웨어의 기능에서부터 시작하여 점차적으로 구체화하고, 알고리즘, 자료 구조 등 상세한 내역은 가능한 뒤로 미루어 진행

<hr>

## 정보 은닉(Information Hiding)

> 한 모듈 내부에 포함된 절차와 자료들의 정보가 감추어져 다른 모듈이 접근하거나 변경하지 못하도록 하는 기법

- 어떤 모듈이 소프트웨어 기능을 수행하는데 반드시 필요한 기능이 있어 정보 은닉된 모듈과 커뮤니케이션할 필요가 있을 때는 필요한 정보만 인터페이스를 통해 주고 받음
- 정보 은닉을 통해 모듈을 독립적으로 수행할 수 있고, 하나의 모듈이 변경되더라도 다른 모듈에 영향을 주지 않으므로 수정, 시험, 유지보수가 용이


<hr>

## 소프트웨어 아키텍처의 품질 속성

#### 시스템 측면

| 품질 속성 | 내용 |
|-|-|
| 성능(Performance) | 사용자의 요청과 같은 이벤트가 발생했을 떄, 이를 적절하고 빠르게 처리하는 것 |
| 보안성(Security) | 허용되지 않은 접근을 막고, 허용된 접근에는 적절한 서비스를 제공하는 것 |
| 가용성(Availability) | 장애 없이 정상적으로 서비스를 제공하는 것 |
| 기능성(Functionality) | 사용자가 요구한 기능을 만족스럽게 구현하는 것 |
| 사용성(Usability) | 사용자가 소프트웨어를 사용하는데 헤매지 않도록 명확하고 편리하게 구현되도록 구현하는 것 |
| 변경 용이성(Modifiability) | 시스템의 용량, 처리능력 등을 확장시켰을 떄 이를 효과적으로 활용할 수 있도록 구현하는 것 |
| 확장성(Scalability) | 시스템의 용량, 처리능력 등을 확장시켰을 때 이를 효과적으로 활용할 수 있도록 구현하는 것 |

<br>

#### 비즈니스 측면

| 품질 속성 | 내용 |
|-|-|
| 시장 적시성 | 정해진 시간에 맞춰 프로그램을 출시하는 것 |
| 비용과 혜택 | 개발 비용을 더 투자하여 유연성이 높은 아키텍처를 만들것인지를 결정 |
| 예상 시스템 수명 | 시스템을 얼마나 오랫동안 사용할 것인지를 고려하는 것 |
| 기타 속성 | 목표 시장, 공개 일정, 기존 시스템과의 통합 등 |

<br>

#### 아키텍처 측면

| 품질 속성 | 내용 |
|-|-|
| 개념적 무결성 | 전체 시스템과 시스템을 이루는 구성요소들 간의 일관성을 유지하는 것 |
| 정확성, 완결성 | 요구사항과 요구사항을 구현하기 위해 발생하는 제약사항들을 모두 충족시키는 것 |
| 구축 가능성 | 모듈 단위로 구분된 시스템을 적절하게 분배하여 유연하게 일정을 변경할 수 있도록 하는 것 |
| 기타 속성 | 변경성, 시험성, 적응성, 일치성, 대체성 등| 


<hr>

## 소프트웨어 설계 과정

1. **설계 목표 설정**: 시스템의 개방 방향을 명확히 하기 위해 설계에 영향을 주는 비즈니스 목표, 운선수위 등의 요구사항을 분석하여 전체 시스템의 설계 목표를 설정
2. **시스템 타입 결정**: 시슽메과 서브시스템의 타입을 결정하고, 설계 목표와 함께 고려하여 아키텍처 패턴을 선택
3. **아키택처 패턴 적용**: 아키텍처 패턴을 참조하여 시스템의 표준 아키텍처를 설계
4. **서브시스템의 구체화**: 서브시스템의 기능 및 서브시스템 간의 상호작용으로 위한 동작과 인터페이스를 정의
5. **검토**: 아키텍처가 설계 목표에 부합하는지 요구사항이 잘 반영되었는지, 설계의 기본 원리를 만족하는지 등을 검토

<hr>

## 오답

- 1. 소프트웨어 아키텍처의 4+1 관점 중 물리적 시스템에서 사용하는 소프트웨어 서브 시스템 모듈이 어떻게 구조화되어 있는지에 중점을 둔 관점
➡️ 구현 뷰
- 2. 소프트웨어 품질 속성 중 소프트웨어를 사용할 때 혼란스러워하거나 순간 고민하지 않게 하는 편의성을 의미하는 것
➡️ 사용성(Usability)