---
layout: post
title: 30. 디자인 패턴
date: 2026-02-01 09:00 +09:00
categories: [IEIP, Subject 2]
tags: [IEIP]
---

## 디자인 패턴의 개요

> 각 모듈의 세분화된 역할이나 모듈들 간의 인터페이스와 같은 코드를 작성하는 수준의 세부적인 구현 방안을 설게할 때 참조할 수 있는 전형적인 해결 방식 또는 예제를 의미

- 문제 및 배경, 실제 적용된 사례, 재사용이 가능한 샘플 코드 등으로 구성됨
- 개발 과정 중에 문제가 발생하면 새로 해결책을 구상하는 것보다 문제에 해당하는 디자인 패턴을 참고하여 적용하는 것이 더 효율적
- 디자인 패턴은 한 패턴에 변형을 가하거나 특정 요구사항을 반영하면 유사한 형태의 다른 패턴으로 변화되는 특징이 있음
- 디자인 패턴은 1995년 GoF(Gang of Four)라고 불리는 에릭 감마, 리차드 헬름, 랄프 존슨, 존 블리시디스가 처음으로 구체화 및 체계화
- GoF의 디자인 패턴은 수많은 디자인 패턴들 중 가장 일반적인 사례에 적용될 수 있는 패턴들을 분류하여 정리함으로써 지금까지도 소프트웨어 공학이나 현업에서 가장 많이 사용되고 있음
- GoF의 디자인 패턴은 생성 패턴(5개), 구조 패턴(7개), 행위 패턴(11개)으로 총 23개의 패턴으로 구성됨

## 아키텍처 패턴 vs 디자인 패턴

- 아키텍처 패턴은 디자인 패턴보다 상위 수준의 설계에 사용됨
- 아키텍처 패턴은 전체 시스템의 구조를 설계하기 위한 참조 모델이라면, 디자인 패턴은 서브시스템에 속하는 컴포넌트들과 그 관계를 설계하기 위한 참조 모델
- 몇몇 디자인 패턴은 특정 아키텍처 패턴을 구현하는데 유용하게 사용됨

<hr>

## 장단점

- 범용적인 코딩 스타일로 인해 구조 파악이 용이
- 객체지향 설계 및 구현의 생산성을 높이는 데 적합
- 검증된 구조의 재사용을 통해 개발 시간과 비용이 절감
- 초기 투자 비용이 부담될 수 있음
- 개발자 간의 원활한 의사소통이 가능
- 설계 변경 요청에 대한 유연한 대처가 가능
- 객체지향을 기반으로 한 설계와 구현을 다루므로 다른 기반의 애플리케이션 개발에는 적합하지 않음

<hr>

## 생성 패턴(Cerational Patterns)

#### 추상 팩토리(Abstract Factory)

- 구체적인 클래스에 의존하지 않고 인터페이스를 통해 서로 연관/의존하는 객체들의 그룹으로 생성하여 추상적으로 표현
- 연관된 서브 클래스를 묶어 한 번에 교체하는 것이 가능

<br>

#### 빌더 (Builder)

- 작게 분리된 인스턴스를 건축하듯이 조합하여 객체를 생성
- 객체의 생성 과정과 표현 방법을 분리하고 있어, 동일한 객체 생성에서도 서로 다른 결과를 만들어낼 수 있음

<br>

#### 팩토리 메서드(Factory Method)

- 객체 생성을 서브클래스에서 처리하도록 분리하여 캡슐화한 패턴
- 상위 클래스에서 인터페이스만 정의하고 실제 생성은 서브 클래스가 담당
- 시존 코드를 수정하지 않고 새로운 인스턴스를 다른 방법으로 생성하도록 확장할 수 있음
- 가상 생성자(Virtual Constructor)라고도 함

<br>

#### 프로토타입(Prototype)

- 원본 객체를 복제하는 방법으로 객체를 생성하는 패턴
- 일반적인 방법으로 객체를 생성하며, 비용이 큰 경우 주로 이용


<br>

#### 싱글톤(Singleton)

- 하나의 객체를 생성하면 생성된 객체를 어디서든 참조할 수 있지만 여러 프로세스가 동시에 참조할 수는 없음
- 클래스 내에서 인스턴스가 하나뿐임을 보장하고, 불필요한 메모리 낭비를 최소화할 수 있음

<hr>

## 구조 패턴(Structural Patterns)

> 구조 패턴은 클래스나 객체들을 조합하여 더 큰 구조로 만들 수 있게 해주는 패턴

#### 어댑터(Adapter)

- 호환성이 없는 클래스들의 인터페이스를 다른 클래스가 이용할 수 있도록 변환해주는 패턴
- 기존의 클래스를 이용하고 싶지만 인터페이스가 일치하지 않을 때 이용

<br>

#### 브리지(Bridge)

- 구현부에서 추상층을 분리하여 서로가 독립적으로 확장할 수 있도록 구성한 패턴
- 기능과 구현을 두 개의 별도 클래스로 구현

<br>

#### 컴포지트(Composite)

- 여러 객체를 가진 복합 객체와 단일 객체를 구분 없이 다루고자 할 때 사용하는 패턴
- 객체들을 트리 구조로 구성하여 디렉터리 안에 디렉터리가 있듯이 복합 객체 안에 복합 객체가 포함되는 구조를 구현 가능

<br>

#### 데코레이터(Decorator)

- 객체 간의 결합으로 통해 능동적으로 기능들을 확장할 수 있는 패턴
- 임의의 객체에 부가적인 기능을 추가하기 위해 다른 객체들을 덧붙이는 방식으로 구현

<br>

#### 퍼사드(Facade)

- 복잡한 서브 클래스들을 피해 더 상위에 인터페이스를 구성함으로써 서브 클래스들의 기능을 간편하게 사용할 수 있도록 하는 패턴
- 서브 클래스들 사이의 통합 인터페이스를 제공하는 Wrapper 객체가 필요

<br>

#### 플라이웨이트(Flyweight)

- 인스턴스가 필요할 때마다 매번 생성하는 것이 아니고 가능한 한 공유해서 사용함으로써 메모리를 절약하는 패턴
- 다수의 유사 객체를 생성하거나 조작할 때 유용하게 사용 가능

<br>

#### 프록시(Proxy)

- 접근이 어려운 객체와 여기에 연결하려는 객체 사이에서 인터페이스 역할을 수행하는 패턴
- 네트워크 연결, 메모리의 대용량 객체로의 접근 등에 주로 이용

<hr>

## 행위 패턴(Behavioral Patterns)

> 하나의 객체로 수행할 수 없는 작업을 여러 객체로 분배하면서 결합도를 최소화할 수 있도록 도와줌

#### 책임 연쇄(Chain of Responsibility)

- 요청을 처리할 수 있는 객체가 둘 이상 존재하여 한 객체가 처리하지 못하면 다음 객체로 넘어가는 형태의 패턴
- 요청을 처리할 수 있는 각 객체들이 고리로 묶여 있어 요청이 해결될 때까지 고리를 따라 책임을 넘김

<br>

#### 커맨드(Command)

- 요청을 객체의 형태로 캡슐화하여 재이용하거나 취소할 수 있도록 요청에 필요한 정보를 저장하거나 로그에 남기는 패턴
- 요청에 사용되는 각종 명령어들을 추상 클래스와 구체 클래스로 분리하여 단순화함

<br>

#### 인터프리터(Interpreter)

- 언어에 문법 표현을 정의하는 패턴
- SQL이나 통신 프로토콜 같은 것을 개발할 때 사용

<br>

#### 반복자(Iterator)

- 자료 구조와 같이 접근이 잦은 객체에 대해 동일한 인터페이스를 사용하도록 하는 패턴
- 내부 표현 방법의 노풀 없이 순차적인 접근이 가능

<br>

#### 중재자(Mediator)

- 수많은 객체들 간의 복잡한 상호작용을 캡슐화하여 객체로 정의하는 패턴
- 객체 사이의 의존성을 줄여 결합도를 감소시킬 수 있음
- 중재자는 객체 간의 통제와 지시의 역할을 수행

<br>

#### 메멘토(Memento)

- 특정 시점에서의 객체 내부 상태를 객체화함으로써 이후 요청에 따라 객체를 해당 시점의 상태로 돌릴 수 있는 기능을 개발할 때 주로 이용