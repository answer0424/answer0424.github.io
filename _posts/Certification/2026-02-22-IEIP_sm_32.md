---
layout: post
title: 1과목 - 애플리케이션 설계
date: 2026-02-22 09:00 +09:00
categories: [IEIP, Subject 1]
tags: [IEIP]
---

## 소프트웨어 생명 주기

#### 폭포수 모형

- 이전 단계로 돌아갈 수 없다는 전제하에 각 단계를 확실히 매듭짓고 그 결과를 철저하게 검토하여 승인 과정을 거친 후에 다음 단계를 진행하는 개발 모형
- 보혐이 제시한 고전적 생명 주기 모형
- 가장 오래되고 가장 폭넓게 사용된 전통적인 소프트웨어 생명 주기 모형
- 개발 과정에서 발생하는 요구사항을 반영하기 어려움

<br>

#### 나선형 모형

- 보헴이 제안한 것으로 폭포수 모형과 프로토타입 모형의 장점에 위험 분석 기능을 추가한 모형
- 나선을 따라 돌듯이 여러 번의 소프트웨어 개발 과정을 거쳐 점진적으로 완벽한 최종 소프트웨어를 개발하는 것
- 계획 수립 ➡️ 위험 분석 ➡️ 개발 및 검증 ➡️ 고객 평가 과정이 반복적으로 수행됨

<br>

#### 애자일 개발 4가지 핵심 가치

- 프로세스와 도구보다는 개인과 상호작용에 더 가치를 둠
- 방대한 문서보다는 실행되는 SW에 가치를 둠
- 계약 협상보다는 고객과 협업에 더 가치를 둠
- 계획을 따르기 보다는 변화에 반응하는 것에 더 가치를 둠

---

## 소프트웨어 개발 방법론

#### 객체지향 방법론

- 소프트웨어를 개발할 때 기계의 부품을 조립하듯이 객체들을 조립해서 필요한 소프트웨어를 구현하는 방법론
- 요구분석 ➡️ 설계 ➡️ 구현 ➡️ 테스트 및 검증 ➡️ 인도

---

## 스크럼 기법

#### 스크럼 팀

- 제품 책임자: 제품 백로그를 관리하는 역할
- 스크럼 마스터: 스크럼 팀이 스크럼을 올바르게 적용할 수 있도록 지원하는 역할
- 개발 팀: 제품 백로그에 있는 작업을 수행하여 제품을 개발하는 역할

<br>

#### 스크럼 개발 프로세스

- 제품 백로그: 제품에 필요한 기능과 요구사항을 우선순위에 따라 나열한 목록
- 스프린트 계획 회의: 스프린트 동안 수행할 작업을 선택하고 계획하는 회의
- 스프린트: 일정 기간 동안 개발 팀이 작업을 수행하는 반복적인 개발 주기
- 일일 스크럼 회의: 매일 짧은 시간 동안 진행 상황을 공유하고 문제를 해결하는 회의
- 스프린트 검토 회의: 스프린트가 끝난 후 개발된 제품을 검토하는 회의
- 스프린트 회고: 스프린트가 끝난 후 개발 팀이 개발 프로세스를 개선하기 위해 회고하는 회의

---

## XP 기법

#### 개요

- 수시로 발생하는 고객의 요구사항에 유연하게 대응하기 위해 고객의 참여와 개발 과정의 반복을 극대화하여 개발 생산성을 향상시키는 방법
- 대표적인 애자일 방법 중 하나
- 짧고 반복적인 개발 주기, 단순한 설계, 고객의 적극적인 참여를 통해 소프트웨어를 빠르게 개발하는 것을 목적으로 함
- 자동화된 테스팅 도구를 사용하여 테스트를 지속적으로 수행

<br>

#### XP의 5가지 핵심 가치

- 의사소통: 팀원 간의 원활한 의사소통을 통해 협업을 촉진
- 단순성: 불필요한 복잡성을 제거하여 단순한 설계를 추구
- 피드백: 지속적인 피드백을 통해 개발 과정에서 발생하는 문제를 신속하게 해결
- 용기: 새로운 아이디어를 시도하고 실패를 두려워하지 않는 용기를 강조
- 존중: 팀원 간의 상호 존중을 통해 협력적인 개발 환경을 조성

<br>

#### XP 개발 프로세스

- 사용자 스토리: 고객이 원하는 기능이나 요구사항을 간단한 이야기 형식으로 표현한 것
- 릴리스 계획 수립: 사용자 스토리를 기반으로 릴리스 계획을 수립하는 과정
- 스파이크: 특정 기술적 문제나 불확실한 요구사항을 해결하기 위해 짧은 시간 동안 집중적으로 연구하는 활동
- 이터레이션: 짧은 개발 주기로, 각 이터레이션마다 사용자 스토리를 구현하고 테스트하는 과정을 반복
- 승인 검사: 고객이 구현된 기능을 검토하고 승인하는 과정
- 소규모 릴리즈: 완성된 기능을 작은 단위로 릴리스하여 고객에게 빠르게 제공하는 과정

---

## 요구사항 분석 CASE와 HIPO

#### 자동화 도구 사용의 이점

- 표준화와 보고를 통한 문서화 품질 개선
- 데이터베이스가 모두에게 이용 가능하다는 점에서 분석자들간의 적절한 조정
- 교차 참조도와 보고서를 통한 결함, 생략, 불일치 등의 발견 용이성
- 명세에 대한 유지보수 비용의 축소

<br>

#### SADT

- SoftTech 상에서 개발한 구조적 분석 및 설계 도구
- 블록 다이어그램을 채택한 자동화 도구

<br>

#### HIPO

- 시스템 분석 및 설계나 문서화할 때 사용되는 기법으로 시스템 실행 과정인 입력, 처리, 출력의 기능을 나타냄
- 하향식 소프트웨어 개발을 위한 도구
- HIPO Chart의 종류
  - 가시적 도표
  - 총체적 도표
  - 세부적 도표

---

## UML (⭐)

#### UML

- 시스템 분석, 설계, 구현 등 시스템 개발 과정에서 시스템 개발자와 고객 또는 개발자 상호간의 의사소통이 원활하게 이루어지도록 표준화한 대표적인 객체지향 모델링 언어
- 구성 요소: 사물, 관계, 다이어그램

<br>

#### 사물(Things)

- 모델을 구성하는 가장 중요한 기본 요소로 다이어그램안에서 관계가 형성될 수 있는 대상들을 말함
- 종류: 구조 사물, 행동 사물, 그룹 사물, 주해 사물

<br>

#### 실체화(Realization) 관계

- 사물이 할 수 있거나 해야 하는 기능으로 서로를 그룹화 할 수 있는 관계를 표현함
- 한 사물이 다른 사물에게 오퍼레이션을 수행하도록 지정하는 의미적 관계

<br>

#### 일반환(Generalization) 관계

- 하나의 사물이 다른 사물에 비해 더 일반저긍로 구체적인지 표현
- 예를 들어 차는 버스, 트럭, 택시보다 일반적인 개념이고 반대로는 구체적인 개념임

<br>

#### 구조적(정적) 다이어그램의 종류

- 클래스 다이어그램
- 객체 다이어그램
- 컴포넌트 다이어그램
- 배치 다이어그램
- 복합체 구조 다이어그램
- 패키지 다이어그램

<br>

##### 행위(동적) 다이어그램의 종류

- 유스케이스 다이어그램
- 순차 다이어그램
- 커뮤니케이션 다이어그램
- 상태 다이어그램
- 활동 다이어그램
- 상호작용 개요 다이어그램
- 타이밍 다이어그램

<br>

#### 스테레오 타입

- UML에서 표현하는 기본 기능 외에 추가적인 기능을 표현하기 위해 사용함
- 길러멧이라고 부르는 겹화살괄호를 사이에 표현할 형태를 기술

---

## 주요 UML 다이어그램

#### 유스케이션 다이어그램의 구성 요소

- 시스템/시스템 범위: 시스템 경계로 시스템과 외부 세계를 구분하는 선
- 액터: 시스테ㅁ과 상호작용을 하는 모든 외부 요소
  - 주액터: 시스템을 사용함으로써 이득을 얻는 대상으로 주로 사람이 해당
  - 부액터: 주액터 목적 달성을 위해 시스템에 서비스를 제공하는 외부 시스템으로 조직이나 기관 등이 될 수 있음
- 유스케이스: 사용자가 보는 관점에서 시스템이 액터에게 제공하는 서비스 또는 기능을 표현한 것
- 관계: 액터와 유스케이스 사이의 관계로 연관, 포함, 확장, 일반화 등이 있음

<br>

#### 클래스 다이어그램 - 오퍼레이션

- 클래스가 수행할 수 있는 동작으로 함수라고도 함

<br>

#### 순차 다이어그램의 개요

- 시스템이나 객체들이 메시지를 주고받으며 시간의 흐름에 따라 상호작용하는 과정을 액터, 객체, 메시지 등의 요소를 사용하여 그림으로 표현한 것
- 순차 다이어그램은 시스템이나 객체들의 상호작용 과정에서 주고받는 메시지를 표현
- 순차 다이어그램에서 수직 방향은 시간의 흐름을 나타냄

---

## 소프트웨어 아키텍처 (⭐)

#### 소프트웨어 아키텍처의 설계

- 소프트웨어 개발 시 적용되는 원칙과 지침
- 이해하기 쉽고 명확해야 함
- 기본적으로 좋은 품질을 유지하면서 사용자의 비기능적 요구사항으로 나타난 제약을 반영하고 기능적 요구사항을 구현하는 방법
- 애플리케이션의 분할 방법과 분할된 모듈에 할당될 기능, 모듈간의 인터페이스 등을 결정

<br>

#### 소프트웨어 아키텍처 뷰

- 유스케이스 뷰: 시스템 외부 사용자의 관점에서 사용 사례와 이들 간의 관계를 정의하며, 다른 뷰를 검증하는 용도로 사용하는 뷰
- 논리적 뷰: 설계자의 관점에서 시스템의 기능적인 요구사항이 제공되는 방법을 정의하는 뷰
- 구현 뷰: 개발자의 관점에서 서브 시스템 모듈이 어떻게 구조화되어 있는지 확인하기 위해 소프트웨어 구성을 보여주는 뷰
- 프로세스 뷰: 시스템 통합자의 관점에서 자원의 효율적인 사용, 이벤트 처리 등을 표현한 뷰
- 배포 뷰: 테스터의 관점에서 컴포넌트가 어떻게 배포되고 연결되는지 보여주는 뷰

<br>

#### 모듈화

- 소프트웨어의 성능을 향상시키기 위해 소프트웨어를 여러 개의 모듈로 나누는 것
- 모듈은 소프트웨어의 기능적 단위로, 독립적으로 개발, 테스트, 유지보수할 수 있는 단위

<br>

#### 정보은닉

- 모듈의 내부 구현을 숨기고 인터페이스를 통해서만 접근할 수 있도록 하는 원칙
- 모듈의 내부 구현이 변경되더라도 인터페이스가 유지되면 다른 모듈에 영향을 주지 않음

<br>

#### 사용성

- 소프트웨어가 사용하기 쉽고 편리한 정도를 나타내는 개념

---

## 아키텍처 패턴

#### 장점

- 시행착오를 줄여 개발 시간을 단축시키고, 고품질의 소프트웨어를 생산할 수 있음
- 검증된 구조로 개발하기 때문에 안정적인 개발이 가능
- 이해관계자들이 공통된 아키텍처를 공유할 수 있어 의사소통이 간편해짐
- 시스템의 구조를 이해하는 것이 쉬워 개발에 참여하지 않은 사람도 손쉽게 유지보수를 할 수 있음
- 시스템의 특정을 개발전에 예측하는 것이 가능

<br>

#### 파이프-필터 패턴

- 데이터 스트림 절차의 각 단계를 필터 컴포넌트로 캡슐화하여 파이프를 통해 데이터를 전송하는 패턴
- 필터 간 데이터 이동 시 데이터 변환으로 인한 오버헤드가 발생

<br>

#### MVC(Model-View-Controller) 패턴

- 모델(Model): 서브시스템의 핵심 기능과 데이터를 보관
- 뷰(View): 사용자에게 정보를 표시함
- 컨트롤러(Controller): 사용자로부터 입력된 변경 요청을 처리하기 위해 모델에게 명령을 보냄

---

## 객체 지향(Object-Oriented) (⭐)

#### 함수

- 객체가 수행하는 기능으로 객체가 갖는 데이터를 처리하는 알고리즘
- 객체의 상태를 참조하거나 변경하는 수단이 되는 것으로 메서드라고도 함

<br>

#### 클래스

- 공통된 속성과 연산을 갖는 객체의 집합으로 객체의 일반적인 타입을 의미함
- 클래스에 속한 각각의 객체를 인스턴스라고 함

<br>

#### 추상 클래스

- 구체 클래스에서 구현하려는 기능들의 공통점만을 모아 추상화한 클래스
- 인스턴스 생성이 불가능하여 구체 클래스가 추상 클래스를 상속받아 구체화한 후 구체 클래스의 인스턴스를 생성하는 방식으로 사용함

<br>

#### 캠슐화

- 데이터와 데이터를 처리하는 함수를 하나로 묶는 것을 의미
- 캡슐화된 객체의 세부 내용은 외부에 은폐됨
- 캡슐화된 객체는 외부 모듈의 변경으로 인한 파급 효과가 적음인터페이스가 단순화됨
- 객체 간의 결합도가 낮아짐

<br>

#### 상속

- 이미 정의된 상위 클래스의 모든 속성과 연산을 하위 클래스가 물려받는 것

<br>

#### 다형성

- 메시지에 의해 객체가 연산을 수행하게 될 때 하나의 메시지에 대해 각각의 객체가 가지고 있는 고유한 방법으로 응답할 수 있는 능력

- 오버로딩: 메서드의 이름은 같지만 인수를 받는 자료형과 개수를 달리하여 여러 기능을 정의할 수 있음
- 오버라이딩: 상위 클래스에서 정의한 메소드와 이름은 같지만 메소드 안의 실행 코드를 달리하여 자식 클래스에서 정의해서 사용할 수 있음

--- 

## 디자인 패턴 (⭐)

#### 디자인 패턴

- 각 모듈의 세분화된 역할이나 모듈들 간의 인터페이스와 같은 코드를 작성하는 수준의 세부적인 구현 방안을 설계할 떄 참조할 수 있는 전형적인 해결 방식 또는 예제를 의미
- 디자인 패턴 유형: 생성 패턴, 구조 패턴, 행위 패턴

<br>

#### 아키텍처와 디자인 패턴의 차이점

- 아키텍처 패턴은 디자인 패턴보다 상위 수준의 설계에 사용됨
- 아키텍처 패턴이 전체 시슽메의 구조를 설계하기 위한 참조모델이라면, 디자인 패턴은 서브시스템에 속하는 컴포넌트들과 그 관계를 설계하기 위한 참조 모델

<br>

#### 생성 패턴

- 추상 팩토리: 구체적인 클래스에 의존하지 않고 인터페이스를 통해 서로 연관,의존하는 객체들의 그룹으로 생성하여 추상적으로 표현함
- 빌더: 작게 분리된 인스턴스를 건축하듯이 조합하여 객체를 생성
- 팩토리 메소드: 객체 생성을 서브 클래스에서 처리하도록 분리하여 캡슐화한 패턴으로 상위 클래스에서 인터페이스만 정의하고 실제 생성은 서브클래스가 담당함
- 프로토타입: 원본 객체를 복제하는 방법
- 싱글톤: 하나의 객체를 생성하면 생성된 객체를 어디서든 참조할 수 있지만, 여러 프로세스가 동시에 참조할 수 없음

<br>

#### 구조 패턴

- 어댑터: 호환성이 없는 클래스들의 인터페이스를 다른 클래스가 이용할 수 있도록 변환해주는 패턴
- 브리지: 구현부에서 추상층을 분리하여, 서로가 독립적으로 확장할 수 있도록 구성한 패턴
- 컴포지트: 여러 객체를 가진 복합 객체와 단일 객체를 구분없이 다루고자 할 때 사용하는 패턴
- 데코레이터: 객체 간의 결합을 통해 을동적으로 기능들을 확장할 수 있는 패턴으로 임의의 객체에 부가적인 기능을 추가하기 위해 다른 객체들을 덧붙이는 방식으로 구현
- 퍼싸드: 복잡한 서브 클래스들을 피해 더 상위에 인터페이스를 구성함으로써 서브 클래스들의 기능을 간편하게 사용할 수 있도록 하는 패턴
- 플라이웨이트: 인스턴스가 필요할 때마다 매번 생성하는 것이 아니고 가능한 한 공유해서 사용함으로써 메모리를 절약하는 패턴
- 프록시: 접근이 어려운 객체와 여기에 연결하려는 객체 사이에서 인터페이스 역할을 수행하는 패턴

<br>


#### 행위 패턴

- 책임 연쇄: 요청을 처리할 수 있는 객체가 둘 이상 존재하여 한 객체가 처리하지 못하면 다음 객체로 넘어가는 형태의 패턴
- 커맨트: 요청을 객체의 형태로 캡슐화하여 재이용하거나 취소할 수 있도록 요청에 필요한 정보를 저장하거나 로그에 남기는 패턴
- 인터프리터: 언어에 문법 표현을 정의하는 패턴으로 SQL이나 통신 프로토콜과 같은 것을 개발할 때 사용
- 반복자: 자료 구조와 같이 접근이 잦은 객체에 대해 동일한 인터페이스를 사용하도록 하는 패턴
- 중재자: 수많은 객체들 간의 복잡한 상호작용을 캡슐화하여 객체로 정의하는 패턴
- 메멘토: 특정 시점에서의 객체 내부 상태를 객체화함으로써 이후 요청에 따라 객체를 해당 시점의 상태로 돌릴 수 있는 기능을 제공하는 패턴
- 옵서버: 한 객체의 상태가 변화하면 객체에 상속되어 있는 다른 객체들에게 변화된 상태를 전달하는 패턴
- 상태: 객체의 상태에 따라 동일한 동작을 다르게 처리해야 할 때 사용하는 패턴
- 전략: 동일한 계열의 알고리즘들을 개별적으로 캡슐화하여 상호 교환할 수 있게 정의하는 패턴
- 템플릿 메소드: 상위 클래스에서 골격을 정의하고, 하위 클래스에서 세부 처리를 구체화하는 구조의 패턴
- 방문자: 각 클래스들의 데이터 구조에서 처리 기능을 분리하여 별도의 클래스로 구성하는 패턴