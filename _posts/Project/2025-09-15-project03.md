---
layout: post
title: 트랜잭션
date: 2025-09-18 09:00 +09:00
categories: [project, new_car ]
tags: [project]
---

## 트랜잭션

> 트랜젝션은 여러 DB 작업을 하나의 논리적인 단위로 묶어, 전부 성공하거나 전부 실패하도록 보장하는 메커니즘
> 
> 즉, 데이터의 일관성, 무결성을 위한 핵심 도구

<br>

## ACID 특성 - 트랜잭션이 지키는 성질

- Atomicity(원자성): 트랜잭션의 모든 작업은 전부 성공하거나 전부 실패한다
- Consistency(일관성): 트랜잭션이 끝나면 DB는 정의된 제약조건을 만족하는 상태로 유지한다
- Isolation(격리성): 동시에 수행되는 트랜잭션들이 서로의 중간 상태를 보지 못하게 한다
- Durability(지속성): 트랜잭션이 커밋되면 그 결과는 영구 저장된다

<br>

## 트랜잭션의 생명주기

1. 트랜잭션 시작
2. 여러 CRUD 작업 수행
3. 성공 ➡️ `COMMIT` (변경사항 영구 저장)
4. 실패 ➡️ `ROLLBACK` (변경사항 모두 취소)

- JDBC 기본: 대부분의 DB 드라이버는 auto-commit이 기본, 애플리케이션에서 명시적으로 트랜잭션을 관리하면 auto-commit을 끄고 여러 작업을 묶음
- Savepoint: 트랜잭션 내부에서 중간 복구 지점을 만든 뒤 부분 rollback 가능

<br>

## 격리수준(Isolation levels)과 발생 가능한 이상 현상

- READ_UNCOMMITTED
  - 허용: Dirty Read(허용되지 않은 값 읽음), Non-repeatable Read, Phantom Read
- READ_COMMITTED
  - 방지: Dirty Read
  - 허용: Non-repeatable Read, Phantom Read
- REPEATABLE_READ
  - 방지: Dirty Read, Non-repeatable Read
  - 허용: Phantom Read
- SERIALIZABLE
  - 가장 엄격: 모든 이상현상 방지

#### 이상현상 예시

- Dirty Read: T1이 값을 수정(아직 커밋 X), T2가 그값을 읽음 ➡️ T1이 롤백되면 T2는 존재하지 않는 값을 읽은 셈
- Non-repeatable Read: T1이 같은 row를 두 번 읽음 ➡️ T2가 중간에 바꿔서 두 번째 읽기 결과가 다름
- Phantom Read: T1이 조건으로 여러 row를 읽음, T2가 새로운 row를 insert ➡️ T1이 같은 쿼리를 재실행하면 추가 row가 보임

<br>

## Spring에서의 트랜잭션(`@Transactional`)

- 주로 서비스 계층에 붙이는 것이 관행
- 주요 속성:
  - `propagation`(전파): REQUIRED(기본), REQUIRES_NEW, SUPPORTS, MANDATORY, NOT_SUPPORTED, NEVER, NESTED
  - `isolation`(격리 수준): DB 격리 수준 지정(READ_COMMITTED 등)
  - `readOnly`: 읽기 전용 최적화(쓰기 시 부작용 가능)
  - `timeout`: 트랜잭션 제한 시간
  - `rollbackFor`/`noRollbackFor`: 어떤 예외에서 롤백할지 제어
- 기본 동작: RuntimeException(unchecked) 발생 시 롤백, Checked exception은 기본적으로 롤백되지 않음

#### 자주 사용하는 propagation 설명

- `REQUIRED`: 기존 트랜잭션이 있으면 참여, 없으면 새로 생성
- `REQUIRES_NEW`: 항상 새 트랜잭션 생성
- `SUPPORTS`: 트랜잭션이 있으면 참여, 없으면 비트랜잭셔널
- `NESTED`: 중첩 트랜잭션- 데이터소스/트랜잭션 매니저 지원 필요

<br>

## 빠른 체크리스트

- 트랜잭션은 서비스 계층에서 선언
- 트랜잭션은 가능한 짧게 유지
- 읽기 전용이면 `readOnly=true` 설정
- checked exception에서도 롤백 필요한 `rollbackFor` 지정
- self-invocation 주의(프록시 때문에 동작 안함)
- 외부 호출/시간 오래 걸리는 작업은 별도 트랜잭션/비동기화
- 분산 트랜잭션은 비용이 크므로 SAGA 등 고려