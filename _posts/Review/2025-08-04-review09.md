---
layout: post
title: 이벤트에 응답하기
date: 2025-08-04 13:00 +09:00
categories: [React_re, adding Interactivity]
tags: [react]
image:
    path: /assets/img/react/React.png
---

## 이벤트 핸들러 추가하기

- 이벤트 핸들러 추가를 위해서는 먼저 함수를 정의하고 이를 적절한 JSX 태그에 `prop 형태로 전달` 해야 함

```jsx
export default function Button() {
    return (
        <button>
            I don't do anything
        </button>
    );
}
```

<br>

#### 버튼을 클릭할 경우 메시지 보여주기

1. `Button` 컴포넌트 내부에 `handleClick` 함수를 선언
2. 해당 함수 내부 로직을 구현, `alert` 사용
3. `<button>` JSX에 `onClick={handleClick}`을 추가

```jsx
export default function Button() {
    function handleClick() {
        alert('You clicked me.');
    }

    return (
        <button onClick={handleClick}>
            Click me
        </button>
    );
}
```

- 이벤트 핸들러의 특징
  - 주로 컴포넌트 내부에서 정의
  - `handle`로 시작하고 그 뒤에 이벤트 함수명을 붙인 함수명을 가정
  - `onClick={handleClick}`, `onMouseEnter={handleMouseEnter}`

<br>

```jsx
<button onClick={function handleClick() {
    alert('You clicked me')l
}}>
```

또는 화살표 함수를 사용할 수 있음

```jsx
<button onClick={() => {
    alert('You clicked me');
}}>
```

<br>

> 주의!!
> 
> 이벤트 핸들러로 전달한 함수들은 호출이 아닌 전달되어야 함
>
> | 함수를 전달하기(올바른 예시) | 함수를 호출하기(잘못된 예시) |
> |-|-|
> | `<button onClick={handleClick}>` | `<button onClick={handleClick()}>` | 
>
> 위 방식의 다른 점은 첫 번째 예시는 사용자가 클릭을 했을 경우에만 작동,
>
> 두 번째 예시는 화면이 렌더링 과정 중 클릭이 없었음에도 불구하고 즉시 함수를 실행
>
> | 함수를 전달하기(올바른 예시) | 함수를 전달하기(잘못된 예시) |
> |-|-|
> | `<button onClick={() => alert('...')}>` | `<button onClick={alert('...')}>` |
{: .prompt-warning }

<br>

## 이벤트 핸들러 내에서 Prop 읽기

- 이벤트 핸들러는 컴포넌트에서 선언되기에 이들은 해당 컴포넌트의 prop에 접근할 수 있음

```jsx
function AlertButton({ message, children }) {
    return (
        <button onClick={() => alert(message)}>
            {children}
        </button>
    );
}

export default function Toolbar() {
    return (
        <div>
            <AlertButton message="Playing">
                Play Movie
            </AlertButton>
            <AlertButton message="Uploading">
                Upload Image
            </AlertButton>
        </div>
    );
}
```

<br>

## 이벤트 핸들어 Prop으로 전달하기

- 부모 컴포넌트로 자식의 이벤트 핸들러를 지정하기를 원할 때 
- `Button` 컴포넌트를 사용하는 위치에 따라 다른 기능을 수행하도록 만들고자 할 때

```jsx
function Button({ onClick, children }) {
  return (
    <button onClick={onClick}>
      {children}
    </button>
  );
}

function PlayButton({ movieName }) {
  function handlePlayClick() {
    alert(`Playing ${movieName}!`);
  }

  return (
    <Button onClick={handlePlayClick}>
      Play "{movieName}"
    </Button>
  );
}

function UploadButton() {
  return (
    <Button onClick={() => alert('Uploading!')}>
      Upload Image
    </Button>
  );
}

export default function Toolbar() {
  return (
    <div>
      <PlayButton movieName="Kiki's Delivery Service" />
      <UploadButton />
    </div>
  );
}
```

- 위 코드에서는 `Toolbar` 컴포넌트가 `PlayButton`과 `UploadButton`을 렌더링함
  - `PlayButton`은 `handlePlayClick`을 `Button` 내 `onClick` prop으로 전달
  - `UploadButton`은 `() => alert('Uploading')`을 `Button` 내 `onClick` prop으로 전달

<br>

## 이벤트 핸들러 Prop 명명하기

- `<button>`과 `<div>` 같은 빌트인 컴포넌트는 `onClick`과 같은 [브라우저 이벤트 이름](https://ko.react.dev/reference/react-dom/components/common#common-props) 만을 지원
- 하지만, 사용자 정의 컴포넌트에서는 이벤트 핸들러 prop의 이름을 원하는대로 명명 가능
- 예시로, `Button` 컴포넌트의 `onClick` prop은 `onSmash`라는 이름으로 호출할 수도 있음

```jsx
function Button({ onSmash, children }) {
    return (
        <button onClick={onSmash}>
            {children}
        </button>
    );
}

export default function App() {
    return (
        <div>
            <Button onSamsh={() => alert('Playing')}>
                Play Movie
            </Button>
            <Button onSamsh={() => alert('Uploading')}>
                Upload Image
            </Button>
        </div>
    );
}
```
{: file='App.js' }

> 중요!
>
> 이벤트 핸들러에 적절한 HTML 테그를 상뇽하고 있는지 확인할 것
>
> 예를 들어 클릭을 처리하기 위해서는 `<div onClick={handleClick}>` 대신 `<button onClick={handleClick}>`을 사용할 것

<br>

## 이벤트 전파

- 이벤트 핸들러는 해당 컴포넌트가 가진 어떤 자식 컴포넌트의 이벤트를 수신할 수도 있음
- 이를 이벤트가 트리를 따라 `bubble`되거나 `전파`된다고 함

```jsx
export default function Toolbar() {
    return (
        <div className="Toolbar" onClick={() => {
            alert('You clicked on the toolbar');
        }}>
            <button onClick={() => alert('Playing')}>
                Play Movie
            </button>
            <button onClick={() => alert('Uploading')}>
                Upload Image
            </button>
        </div>
    );
}
```

> 둘 중 어느 버튼을 클릭하더라도 해당 버튼의 `onClick`이 먼저 실행될 것이며 이후 부모인 `<div>`의 `onClick`이 뒤이어 실행됨

> 주의!
>
> 부여된 JSX 태그 내에서만 실행되는 `onScroll`을 제외한 React 내의 모든 이벤트는 전파됨
{: .prompt-warning }

<br>

## 전파 멈추기

- 이벤트 핸들어는 이벤트 오브젝트를 유일한 매개변수로 받음
- 관습적으로 `event`를 의미하는 `e`로 호출되는 것이 일반적
- 이벤트가 부모 컴포넌트에 닿지 못하도록 막으려면 아래 `Button` 컴포넌트와 같이 `e.stopPropagation()`을 호출

```jsx
function Button({ onClick, children }) {
    return (
        <button onClick={e => {
            e.stopPropagation();
            onClick();
        }}>
            {children}
        </button>
    );
}

export default function Toolbar() {
    return (
        <div className="Toolbar" onClick={() => {
            alert('You clicked on the toolbar');
        }}>
            <Button onClick={() => alert('Playing!')}>
            Play Movie
            </Button>
            <Button onClick={() => alert('Uploading!')}>
                Upload Image
            </Button>
        </div>
    );
}
```

위 함수는 아래와 같은 절차를 따름

1. React가 `<button>`에 전달된 `onClick` 핸들러를 호출
2. `Button`에 정의된 해당 핸들러는 다음을 수행
   - `e.stopPropagation()`을 호출하여 이벤트가 더 이상 bubbling되지 않도록 방지
   - `Toolbar` 컴포넌트가 전달해 준 `onClick` 함수를 호출
3. `Toolbar` 컴포넌트에서 정의된 위 함수가 버튼의 alert를 표시함
4. 전파가 중단되었으므로 부모인 `<div>`의 `onClick`은 실행되지 않음

<br>

## 기본 동작 방지하기

- 일부 브라우저 이벤트는 그와 관련된 기본 브라우저 동작을 가짐
- 일례로 `<form>`의 제출 이벤트는 그 내부의 버튼을 클릭 시 페이지 전체를 리로드하는 것이 기본 동작

```jsx
export default function Signup() {
    return (
        <form onSubmit={() => alert('Submitting')}>
            <input/>
            <button>Send</button>
        </form>
    );
}
```

- 이러한 일이 발생하지 않도록 막기 위해 `e.preventDefault()`를 이벤트 오브젝트에서 호출할 수 있음

```jsx
export default function Signup() {
    return (
        <form onSubmit={e => {
            e.preventDefault();
            alert('Submitting');
        }}>
            <input/>
            <button>Send</button>
        </form>
    );
}
```

- `e.stopPropagation()`은 이벤트 핸들러가 상위 태그에서 실행되지 않도록 멈품
- `e.preventDefault()`는 기본 브라우저 동작을 가진 일부 이벤트가 해당 기본 동작을 실행하지 않도록 방지