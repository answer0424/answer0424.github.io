---
layout: post
title: State, 컴포넌트의 기억 저장소
date: 2025-08-04 13:00 +09:00
categories: [React_re, adding Interactivity]
tags: [react]
image:
    path: /assets/img/react/React.png
---

## 일반 변수로 충분하지 않은 경우

- 다음은 조각상 이미지를 렌더링하는 컴포넌트
- 아래는 작동하지 않는 코드

```jsx
import { sculptureList } from './data.js';

export default function Gallery() {
    let index = 0;

    function handleClick() { 
        index = index + 1;
    }

    let sculpture = sculptureList[index];
    return (
        <>
            <button onClick={handleClick}>
                Next
            </button>
            <h2>
                <i>{sculpture.name} </i>
                by {sculpture.artist}
            </h2>
            <h3>
                ({index + 1} of {sculptureList.length})
            </h3>
            <img
                src={sculpture.url}
                alt={sculpture.alt}
            />
            <p>
                {sculpture.description}
            </p>
        </>
  );
}
```

> `handleClick` 이벤트 핸들러는 지역 변수 `index`를 업데이트하고 있음
> 하지만 변화가 보이지 않는 이유 2가지가 있음

1. 지역 변수는 렌더링 간에 유지되지 않음 React는 이 컴포넌트를 두번째로 렌더링할 때 지역 변수에 대한 변경 사항은 고려하지 않고 처음부터 렌더링함
2. 지역 변수를 변경해도 렌더링을 일으키지 않음 React는 새로운 데이터로 컴포넌트를 다시 렌더링해야 한다는 것을 인식하지 못함

컴포넌트를 새로운 데이터로 업데이트하기 위해선 다음 두 가지가 필요함

1. 렌더링 사이에 데이터를 유지함
2. React가 새로운 데이터로 컴포넌트를 렌더링하도록 유발

`useState` 훅은 이 두가지를 제공

1. 렌더링 간에 데이터를 유지하기 위한 state 변수
2. 변수를 업데이트하고 React가 컴포넌트를 다시 렌더링하도록 유발하는 state setter 함수

<br>

## state 변수 추가하기

```jsx
import { useState } from 'react';
```

그 다음 이줄을

```jsx
let index = 0;
```

다음과 같이 변경

```jsx
const [index, setIndex] = useState(0);
```

- `index`는 state 변수이고 `setIndex`는 setter 함수

> 여기서 `[`와 `]` 문법을 [배열 구조 분해](https://ko.javascript.info/destructuring-assignment)라고 하며, 배열로부터 값을 읽을 수 있게 해줌
>
> `useState`가 반환하는 배열에는 항상 두개의 항목이 존재
{: .prompt-tip }

이것이 `handleClick`에서 함께 작동하는 방식

```jsx 
function handleClick() {
    setIndex(index + 1);
}
```

<br>

## 첫번째 훅 만나기

> React에서 `useState`와 같이 `"use"`로 시작하는 다른 모든 함수를 훅이라고 함
>
> 훅은 React가 오직 `렌더링` 중일 때만 사용할 수 잇는 특별한 함수

> 주의!
>
> 훅(`use`로 시작하는 함수들)은 컴포넌트의 최상위 수준 또는 `커스텀 훅`에서만 호출할 수 있음
>
> 조건문, 반복문 또는 기타 중첩 함수 내부에서는 훅을 호출할 수 없음
{: .prompt-warning }

<br>

## `useState` 해부하기

- `useState`를 호출하는 것은 React에 이 컴포넌트가 무언가를 기억하기를 원한다고 말하는 것

```jsx
const [index, setIndex] = useState(0);
```

- 위의 경우 React가 `index`를 기억하기를 원함

> 중요!
>
> 이 쌍의 이름은 `const [something, setSomething]`과 같이 지정하는 것이 규칙
>
> 원하는 대로 이름을 지을 수 있지만, 규칙을 사용하면 프로젝트 전반에 거쳐 상황을 더 쉽게 이해할 수 있음
{: .prompt-info }

- `useState`의 유일한 인수는 state 변수의 초깃값임
- 위 예시에서 `index` 초기값은 `useState(0)`에 의해 `0`으로 설정

컴포넌트가 렌더링될 때마다, `useState`는 다음 두개의 값을 포함하는 배열을 제공

1. 저장한 값을 가진 state 변수(`index)
2. state 변수를 업데이트라고 React 컴포넌트를 다시 렌더링하도록 유발하는 state setter 함수(`setIndex`)

```jsx
const [index, setIndex] = useState(0);
```

1. 컴포넌트가 처음 렌더링 됨, `index`의 초깃값으로 `useState`를 사용해 `0`을 전달했으므로 `[0, setIndex]`를 반환
2. **state**를 업데이트, 사용자가 버튼을 클릭하면 `setIndex(index + 1)`를 호출, `index`는 `0`이므로 `setIndex(1)`, 이는 React에 `index`는 `1`임을 기억하게 하고 또 다른 렌더링을 유발
3. 컴포넌트가 두번째로 렌더링 됨, React가 여전히 `useState(0)`를 보지만, `index`를 `1`로 설정한 것을 기억하고 있기 때문에, `[1, setIndex]`를 반환
4. 이런식이 계속됨

<br>

## 컴포넌트에 여러 state 변수 지정하기


```jsx
import { useState } from 'react';
import { sculpture } from './data.js';

export default function Gallery() {
    const [index, setIndex] = useState(0);
    const [showMore, setShowMore] = useState(false);

    function handleNextClick() {
        setIndex(index + 1);
    }

    function handleMoreClick() {
        setShowMore(!showMore);
    }

    let sculpture = sculptureList[index];
    return (
    <>
      <button onClick={handleNextClick}>
        Next
      </button>
      <h2>
        <i>{sculpture.name} </i>
        by {sculpture.artist}
      </h2>
      <h3>
        ({index + 1} of {sculptureList.length})
      </h3>
      <button onClick={handleMoreClick}>
        {showMore ? 'Hide' : 'Show'} details
      </button>
      {showMore && <p>{sculpture.description}</p>}
      <img
        src={sculpture.url}
        alt={sculpture.alt}
      />
    </>
  );
}
```

<br>

## State는 격리되고 비공개로 유지됨

> State는 화면에서 컴포넌트 인스턴스에 지역적
>
> 다시 말해, 동일한 컴포넌트를 두 번 렌더링한다면 각 복사본은 완전히 격리된 state를 가짐
>
> 그 중에 하나를 변경해도 다른 하나에는 영향을 미치지 않음

```jsx
import Gallery from './Gallery.js';

export default function Page() {
    return (
        <div className="Page">
            <Gallery />
            <Gallery />
        </div>
    );
}
```

- 추후에 state를 동기화시키는 방법에 대해서 배울 예정