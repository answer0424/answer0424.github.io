---
layout: post
title: 렌더링 그리고 커밋
date: 2025-08-04 13:00 +09:00
categories: [React_re, adding Interactivity]
tags: [react]
image:
    path: /assets/img/react/React.png
---

## UI를 요청하고 제공하는 세가지 단계

1. 렌더링 트리거(손님의 주문을 주방으로 전달)
2. 컴포넌트 렌더링(주방에서 주문을 준비하기)
3. DOM에 커밋(테이블에 주문한 요리 내놓기)

![alt text](/assets/img/react/react_re_11_01.png)

<br>

## 1단계: 렌더링 트리거

1. 컴포넌트의 초기렌더링인 경우
2. 컴포넌트의 **state**가 업데이트된 경우

<br>

#### 초기 렌더링

> 앱을 시작할 때 초기 렌더링을 트리거해야 함
>
> 프레임워크와 샌드박스는 때때로 이 코드를 숨기곤 하지만, 대상 DOM 노드와 함께 `createRoot`를 호출한 다음 해당 컴포넌트로 `render` 메서드를 호출하면 이 작업이 완료

```jsx
import Image from './Image.js';
import { createRoot } from 'react-dom/client';

const root = createRoot(document.getElementById('root'))
root.render(<Image />);
```

<br>

#### State 업데이트 시 리렌더링

> 컴포넌트가 처음으로 렌더링 된 후에는 `set` 함수를 통해 상태를 업데이트하여 추가적인 렌더링을 트리거할 수 있음
>
> 컴포넌트의 상태를 업데이트하면 자동으로 렌더링 대기열에 추가됨

![alt text](/assets/img/react/react_re_11_02.png)

<br>

## 2단계: React 컴포넌트 렌더링

- 초기 렌더링에서 React는 루트 컴포넌트를 호출
- 이후 렌더링에서 React는 state 업데이트가 일어나 렌더링을 트리거한 컴포넌트를 호출

> 재귀적 단계:
>
> 업데이트된 컴포넌트가 다른 컴포넌트를 반환하면 React는 다음으로 해당 컴포넌트를 렌더링하고 해당 컴포넌트도 컴포넌트를 반환된 컴포넌트를 다음에 렌더링하는 방식

```jsx
import Gallery from './Gallery.js';
import { createRoot } from 'react-dom/client';

const root = createRoot(document.getElementById('root'))
root.render(<Gallery />);
```
{: file='index.js' }

```jsx
export default function Gallery() {
  return (
    <section>
      <h1>Inspiring Sculptures</h1>
      <Image />
      <Image />
      <Image />
    </section>
  );
}

function Image() {
  return (
    <img
      src="https://i.imgur.com/ZF6s192.jpg"
      alt="'Floralis Genérica' by Eduardo Catalano: a gigantic metallic flower sculpture with reflective petals"
    />
  );
}
```
{: file='Gallery.js' }

- 초기 렌더링 하는 동안 React는 `<section>`, `<h1>` 그리고 3개의 `<img>` 태그에 대한 DOM 노드를 생성
- 리렌더링하는 동안 React는 이전 렌더링 이후 변경된 속성을 계산 다음 단계인 커밋 단계까지는 해당 정보로 아무런 작업도 수행하지 않음

<br>

## 3단계: React가 DOM에 변경사항을 커밋

- 초기렌더링의 경우 React는 `appendChild()` DOM API를 사용하여 생성한 모든 DOM 노드를 화면에 표시
- 리렌더링의 경우 React는 필요한 최소한의 작업(렌더링하는 동안 계산된 것)을 적용하여 DOM이 최신 렌더링 출력과 일치하도록 함

```jsx
export default function Clock({ time }) {
    return (
        <>
            <h1>{time}</h1>
            <input />
        </>
    );
}
```