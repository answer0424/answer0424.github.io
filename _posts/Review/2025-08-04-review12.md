---
layout: post
title: 스냅샷으로서의 state
date: 2025-08-04 13:00 +09:00
categories: [React_re, adding Interactivity]
tags: [react]
image:
    path: /assets/img/react/React.png
---

## state를 설정하면 렌더링이 동작

> 인터페이스가 이베늩에 반응하기 위해서는 state를 업데이트해야 함

```jsx
import { useState } from 'react';

export default function Form() {
  const [isSent, setIsSent] = useState(false);
  const [message, setMessage] = useState('Hi!');
  if (isSent) {
    return <h1>Your message is on its way!</h1>
  }
  return (
    <form onSubmit={(e) => {
      e.preventDefault();
      setIsSent(true);
      sendMessage(message);
    }}>
      <textarea
        placeholder="Message"
        value={message}
        onChange={e => setMessage(e.target.value)}
      />
      <button type="submit">Send</button>
    </form>
  );
}

function sendMessage(message) {
  // ...
}
```
{: file='App.js' }

1. `onSubmit` 이벤트 핸들러가 실행
2. `setIsSent(true)`가 `isSent`를 `true`로 설정하고 새로운 렌더링을 큐에 넣음
3. React는 새로운 `isSent` 값에 따라 컴포넌트를 다시 렌더링

<br>

## 렌더링은 그 시점의 스냅샷을 찍음

> `렌더링`이란 React가 컴포넌트, 즉 함수를 호출한다는 뜻
>
> 입력에 대한 응답으로 어떤 일이 일어날지 지정하는 이벤트 핸들러와 같은 로직이 포함

1. React가 함수를 다시 호출함
2. 함수가 새로운 JSX 스냅샷을 반환
3. 그러면 React가 함수가 반환한 스냅샷과 일치하도록 화면을 업데이트함

![alt text](/assets/img/react/react_re_12_01.png)

![alt text](/assets/img/react/react_re_12_02.png)

<br>

#### 위 사진의 프로세스가 진행되는 과정


```jsx
import { useState } from 'react';

export default function Counter() {
    const [number, setNumber] = useState(0);

    return (
        <>
            <h1>{number}</h1>
            <button onClick={() => {
                setNumber(number + 1);
                setNumber(number + 1);
                setNumber(number + 1);
            }}> +3</button>
        </>
    );
}
```

> state를 설정하면 다음 렌더링에 대해서만 변경
>
> 첫번째 렌더링에서 `number`는 `0`이었음
>
> 따라서 해당 렌더링의 `onClick` 핸들러에서 `setNumber(number + 1)`가 호출된 후에도 `number`의 값은 여전히 `0`

#### 시각적으로 표현한다면

```jsx
<button onClick={() => {
    setNumber(0 + 1);
    setNumber(0 + 1);
    setNumber(0 + 1);
}}> +3 </button>
```

<br>

## 시간 경과에 따른 State

```jsx
import { useState }  from 'react';

export default function Counter() {
    const [number, setNumber] = useState(0);

    return (
        <>
            <h1>{number}</h1>
            <button onClick={() => {
                setNumber(number + 5);
                alert(number);
            }}>+5</button>
        </>
    );
}
```

<br>

#### 시각적으로 표현한다면

```jsx
setNumber(0 + 5);
alert(0);
```

<br>

#### 경고창에 타이머를 설정한다면?

```jsx
import { useState } from 'react';

export default function Counter() {
  const [number, setNumber] = useState(0);

  return (
    <>
      <h1>{number}</h1>
      <button onClick={() => {
        setNumber(number + 5);
        setTimeout(() => {
          alert(number);
        }, 3000);
      }}>+5</button>
    </>
  )
}
```

<br>

#### 시각적으로 표현한다면?


```jsx
setNumber(0 + 5);
setTimeout(() => {
  alert(0);
}, 3000);
```

> React에 저장된 state는 경고창이 실행될 때 변경되었을 수도 있지만 사용자가 상호작용한 시점에 state 스냅샷을 사용하는 건 이미 예약되어 있던 것
>
> state 변수의 값은 이벤트 핸들러의 코드가 비동기적이더라도 렌더링 내에서 절대 변경되지 않음