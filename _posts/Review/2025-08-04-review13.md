---
layout: post
title: state 업데이트 큐
date: 2025-08-04 13:00 +09:00
categories: [React_re, adding Interactivity]
tags: [react]
image:
    path: /assets/img/react/React.png
---

## React state batches 업데이트

`setNumber(number + 1)`를 세번 호출하므로 "+3" 버튼을 클릭하면 세 번 증가할 것으로 예상할 수 있음

```jsx
import { useState } from 'react';

export default function Counter() {
  const [number, setNumber] = useState(0);

  return (
    <>
      <h1>{number}</h1>
      <button onClick={() => {
        setNumber(number + 1);
        setNumber(number + 1);
        setNumber(number + 1);
      }}>+3</button>
    </>
  )
}
```

- 이전 세션에서 기억할 수 있듯이 각 렌더링의 state값은 도정되어 있으므로, 첫번째 렌더링의 이벤트 핸들러의 `number` 값은 `setNumber(1)`을 몇번 호출하든 항상 0
- 하지만 한 가지 요인이 더 있는데, React는 state 업데이트를 하기 전에 이벤트 핸들러의 모든 코드가 실행될 때까지 기다림

> 이렇게 진행될 경우 너무 많은 리렌더링이 발생하지 않고도 여러 컴포넌트에서 나온 다수의 state 변수를 업데이트할 수 있음

<br>

## 다음 렌더링 전에 동일한 state 변수를 여러 번 업데이트하기

```jsx
import { useState } from 'react';

export default function Counter() {
  const [number, setNumber] = useState(0);

  return (
    <>
      <h1>{number}</h1>
      <button onClick={() => {
        setNumber(n => n + 1);
        setNumber(n => n + 1);
        setNumber(n => n + 1);
      }}>+3</button>
    </>
  )
}
```

- 여기서 `n => n + 1`은 업데이터 함수라고 부름

1. React는 이벤트 핸들러의 다른 코드가 모두 실행된 후에 이 함수가 처리되도록 큐에 넣음
2. 다음 렌더링 중에 React는 큐를 순회하여 최종 업데이트된 state를 제공

<br>

#### state를 교체한 후 업데이트한다면?

```jsx
import { useState } from 'react';

export default function Counter() {
  const [number, setNumber] = useState(0);

  return (
    <>
      <h1>{number}</h1>
      <button onClick={() => {
        setNumber(number + 5);
        setNumber(n => n + 1);
      }}>Increase the number</button>
    </>
  )
}
```

1. `setNumber(number + 5)` : `number`는 `0`이므로 `setNumber(0 + 5)`
2. `setNumber(n => n +1)`: `n => n + 1`는 업데이터 함수

- 최종적으로 6을 결과로 저장하고 `useState`에서 반환

<br>

## 업데이터 함수

#### 명명 규칙

- 업데이터 함수 인수의 이름은 해당 state 변수의 첫글자로 지정하는 것이 일반적

```jsx
setEnabled(e => !e);
setLastName(ln => ln.reverse());
setFriendCount(fc => fc * 2);
```