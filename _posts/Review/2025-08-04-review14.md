---
layout: post
title: 객체 State 업데이트하기
date: 2025-08-05 09:00 +09:00
categories: [React_re, adding Interactivity]
tags: [react]
image:
    path: /assets/img/react/React.png
---

## 변경이랑?

- State에는 모든 종류의 자바스크립트 값을 저장할 수 있음

```jsx
const [x, setX] = useState(0);
```

- 이러한 자바스크립트 값들은 변경할 수 없거나 **읽기 전용**을 의미하는 **불변성**을 가짐
- 값을 교체하기 위해서는 리렌더링이 필요

```jsx
setX(5);
```

- 예를 들어 state에 있는 이러한 객체가 있다고 가정

```jsx
const [position, setPosition] = useState({x: 0, y:0});
```

> 기술적으로 객체 자체의 내용은 바꿀 수 있음
>
> 이것을 **변경(Mutation)**이라고 함

```jsx
position.x = 5;
```

<br>

## State를 읽기 전용인 것처럼 다루기

- 다시 말해, state에 저장한 자바스크립트 객체는 어떤 것이라도 읽기 전용인 것처럼 다루어야 함

```jsx
import { useState } from 'react';

export default function MovingDot() {
    const [position, setPosition] = useState({x: 0, y: 0});

    return (
        <div
            onPointerMove={e =>{
                position.x = e.clientX;
                position.y = e.clientY;
            }}
            style={{
                position: 'relative',
                width: '100vw',
                hight: '100hw',
            }}>
            <div style={{
                position: 'absolute',
                backgroundColor: 'red',
                borderRadius: '50%',
                transform: `translate(${position.x}px, ${position.y}px)`,
                left: -10,
                top: -10,
                width: 20,
                height: 20,
            }}/>
        </div>
    );
}
```

> 위 코드는 잘 작동하지 않음
>
> 문제의 코드

```jsx
onPointerMove={e => {
  position.x = e.clientX;
  position.y = e.clientY;
}}
```

- 해당 코드는 `position`에 할당된 객체를 이전 렌더링에서 수정
- 그러나 React는 state 설정 함수가 없으면 객체가 변경되었는지 알 수 없기 때문에 실제 작동하지 않음
- 이러한 경우 리렌더링을 발생기키려면 새 객체를 생성하여 state 설정 함수로 전달해야 함

```jsx
onPointMove={e => {
    setPosition({
        x: e.clientX,
        y: e.clientY
    });
}}
```

- `setPosition`은 React에게 다음과 같이 요청
  - `position`을 이 새로운 객체로 교체
  - 그리고 해당 컴포넌트를 다시 렌더링

<br>

## 전개 문법으로 객체 복사

- 예를 들어 폼에서 단 한 개의 필드만 수정하고, 나머지 모든 필드는 이전 값을 유지하고 싶을 수도 있음
- 아래 코드의 input 필드는 `onChange` 핸들러가 state를 변경하기 때문에 동작하지 않음

```jsx
import { useState } from 'react';

export default function Form() {
  const [person, setPerson] = useState({
    firstName: 'Barbara',
    lastName: 'Hepworth',
    email: 'bhepworth@sculpture.com'
  });

  function handleFirstNameChange(e) {
    person.firstName = e.target.value;
  }

  function handleLastNameChange(e) {
    person.lastName = e.target.value;
  }

  function handleEmailChange(e) {
    person.email = e.target.value;
  }

  return (
    <>
      <label>
        First name:
        <input
          value={person.firstName}
          onChange={handleFirstNameChange}
        />
      </label>
      <label>
        Last name:
        <input
          value={person.lastName}
          onChange={handleLastNameChange}
        />
      </label>
      <label>
        Email:
        <input
          value={person.email}
          onChange={handleEmailChange}
        />
      </label>
      <p>
        {person.firstName}{' '}
        {person.lastName}{' '}
        ({person.email})
      </p>
    </>
  );
}
```

- 위 코드 또한 객체의 state를 변경하기 때문에 작동하지 않음
- 원하는 동작을 정확히 얻기 위해서 `setPerson`으로 전달해야 함

```jsx
setPerson({
    firstName: e.target.value,
    lastName: person.lastName,
    email: person.email
});
```

- `...` **객체 전개 구문**을 사용하면 모든 프로퍼티를 각각 복사하지 않아도 됨

```jsx
setPerson({
    ...person,  // 이전 필드 복사
    firstName: e.target.value   // 새로운 부분을 덮어쓰기
});
```

```jsx
import { useState } from 'react';

export default function Form() {
  const [person, setPerson] = useState({
    firstName: 'Barbara',
    lastName: 'Hepworth',
    email: 'bhepworth@sculpture.com'
  });

  function handleFirstNameChange(e) {
    setPerson({
      ...person,
      firstName: e.target.value
    });
  }

  function handleLastNameChange(e) {
    setPerson({
      ...person,
      lastName: e.target.value
    });
  }

  function handleEmailChange(e) {
    setPerson({
      ...person,
      email: e.target.value
    });
  }

  return (
    <>
      <label>
        First name:
        <input
          value={person.firstName}
          onChange={handleFirstNameChange}
        />
      </label>
      <label>
        Last name:
        <input
          value={person.lastName}
          onChange={handleLastNameChange}
        />
      </label>
      <label>
        Email:
        <input
          value={person.email}
          onChange={handleEmailChange}
        />
      </label>
      <p>
        {person.firstName}{' '}
        {person.lastName}{' '}
        ({person.email})
      </p>
    </>
  );
}
```

<br>

> 여러 필드에 단일 이벤트 핸들러 사용하기
>
> `[`와 `]` 괄호를 객체 정의 안에 사용하여 동적 이름을 가진 프로퍼티를 명시할 수 있음
> 
> 아래에는 이전 예시와 같지만, 세 개의 다른 이벤트 핸들러 대신 하나의 이벤트 핸들러를 사용하는 예시
>
> ```jsx
> export default function Form() {
>     const [person, setPerson] = useState({
>     firstName: 'Alice',
>     lastName: 'Lee',
>     email: 'alice@sculpture.com',
> });
> function handleChange(e) {
>     setPerson({
>         ...person,
>         [e.target.name]: e.target.value
>     });
> }}
> `e.target.name`은 `<input>` DOM 엘리먼트의 `name` 프로퍼티를 나타냄
{: .prompt-info }

<br>

## 중첩된 객체 갱신하기

```jsx
const [person, setPerson] = useState({
    name: 'Niki de Saint Phalle',
    artwork: {
        title: 'Blue Nana',
        city: 'HamBurg',
        image: 'https://image.com'
    }
});
```

- `person.artwork.city`를 업데이트 하고 싶다면, 변경하는 방법

```jsx
person.artwork.city = 'New Delhi';
```

> 하지만 React에서 state를 변경할 수 없는 것으로 다루어야 함
>
> `city`를 바꾸기 위해서는 먼저(이전 객체의 데이터로 생성된) 새로운 `artwork` 객체를 생성한 뒤, 그것을 가리키는 새로운 `person` 객체를 만들어야 함

```jsx
const nextArtwork = {...person.artwork, city: 'New Delhi' };
const nextPerson = {...person, artwork: nextArtwork };
setPerson(nextPerson);
```

- 또는 단순하게 함수를 호출

```jsx
setPerson({
    ...person,  // 다른 필드 복사
    artwork: {  // artwork 교체
        ...person.artwork,  // 동일한 값 사용
        city: 'New Delhi'   // 적용할 값
    }
});
```

<br>

> 객체들은 사실 중첩되어 있지 않음
>
> 이러한 객체는 코드에서 "중첩되어" 나타남
>
> ```jsx
> let obj = {
>     name: 'Niki de Saint Phalle',
>     artwork: {
>         title: 'Blue Nana',
>         city: 'Hamburg',
>         image: 'https://image.com'
>     }
> };
> ```
> "중첩"은 객체의 동작에 대해 생각하는 부정확한 방법
>
> 코드가 실행될 때, "중첩된" 객체는 없음
> 실제로 두 개의 객체
>
> ```jsx
> let obj1 = {
>     title: 'Blue Nana',
>     city: 'Hamburg',
>     image: 'https://image.com'
> };
> 
> let obj2 = {
>     name: 'Niki de Saint Phalle',
>     artwork: obj1
> };
> ```
>
> 그것들은 프로퍼티를 통해 서로를 "가리키는" 각각의 객체들임
{: .prompt-info }

<br>

## Immer로 간결한 갱신 로직 작성하기

- state가 깊이 중첩되어 있다면 `평탄화`를 고려해볼 것
- `Immer`는 편리하고, 변경 구문을 사용할 수 있게 해주며 복사본 생성을 도워주는 인기 있는 라이브러리임

```jsx
updatePerson(draft => {
    draft.artwork.city = 'Lagos';
});
```

- 위 방법은 일반적인 변경과는 다르게 이전 state를 덮어쓰지 않음

> Immer의 작동 방식
>
> Immer가 제공하는 `draft`는 [Proxy](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Proxy)라고 하는 아주 특별한 객체 타입
>
> 작업자가 하는 일을 "기록"
> 이것이 객체를 원하는만큼 자유롭게 변경할 수 있는 이유

<br>

#### Immer를 사용하기 위해서

1. `package.json`에 `dependencies`를 `use-immer`를 추가
2. `npm install` 실행
3. `import { useState } from 'react'`를 `import { useImmer } from 'use-immer'` 로 교체

- useImmer를 사용하여 교체한 코드

```jsx
import { useImmer } from 'use-immer';

export default function Form() {
  const [person, updatePerson] = useImmer({
    name: 'Niki de Saint Phalle',
    artwork: {
      title: 'Blue Nana',
      city: 'Hamburg',
      image: 'https://i.imgur.com/Sd1AgUOm.jpg',
    }
  });

  function handleNameChange(e) {
    updatePerson(draft => {
      draft.name = e.target.value;
    });
  }

  function handleTitleChange(e) {
    updatePerson(draft => {
      draft.artwork.title = e.target.value;
    });
  }

  function handleCityChange(e) {
    updatePerson(draft => {
      draft.artwork.city = e.target.value;
    });
  }

  function handleImageChange(e) {
    updatePerson(draft => {
      draft.artwork.image = e.target.value;
    });
  }
```

- `Immer`는 state가 중첩되어 있고 객체를 복사하는 것이 중복되는 코드를 만들 때 매우 유용

<br>

