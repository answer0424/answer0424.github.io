---
layout: post
title: 객체 State 업데이트하기
date: 2025-08-05 09:00 +09:00
categories: [React_re, adding Interactivity]
tags: [react]
image:
    path: /assets/img/react/React.png
---

## 변경이랑?

- State에는 모든 종류의 자바스크립트 값을 저장할 수 있음

```jsx
const [x, setX] = useState(0);
```

- 이러한 자바스크립트 값들은 변경할 수 없거나 **읽기 전용**을 의미하는 **불변성**을 가짐
- 값을 교체하기 위해서는 리렌더링이 필요

```jsx
setX(5);
```

- 예를 들어 state에 있는 이러한 객체가 있다고 가정

```jsx
const [position, setPosition] = useState({x: 0, y:0});
```

> 기술적으로 객체 자체의 내용은 바꿀 수 있음
>
> 이것을 **변경(Mutation)**이라고 함

```jsx
position.x = 5;
```

<br>

## State를 읽기 전용인 것처럼 다루기

- 다시 말해, state에 저장한 자바스크립트 객체는 어떤 것이라도 읽기 전용인 것처럼 다루어야 함

```jsx
import { useState } from 'react';

export default function MovingDot() {
    const [position, setPosition] = useState({x: 0, y: 0});

    return (
        <div
            onPointerMove={e =>{
                position.x = e.clientX;
                position.y = e.clientY;
            }}
            style={{
                position: 'relative',
                width: '100vw',
                hight: '100hw',
            }}>
            <div style={{
                position: 'absolute',
                backgroundColor: 'red',
                borderRadius: '50%',
                transform: `translate(${position.x}px, ${position.y}px)`,
                left: -10,
                top: -10,
                width: 20,
                height: 20,
            }}/>
        </div>
    );
}
```

> 위 코드는 잘 작동하지 않음
>
> 문제의 코드

```jsx
onPointerMove={e => {
  position.x = e.clientX;
  position.y = e.clientY;
}}
```

- 해당 코드는 `position`에 할당된 객체를 이전 렌더링에서 수정
- 그러나 React는 state 설정 함수가 없으면 객체가 변경되었는지 알 수 없기 때문에 실제 작동하지 않음
- 이러한 경우 리렌더링을 발생기키려면 새 객체를 생성하여 state 설정 함수로 전달해야 함

```jsx
onPointMove={e => {
    setPosition({
        x: e.clientX,
        y: e.clientY
    });
}}
```

- `setPosition`은 React에게 다음과 같이 요청
  - `position`을 이 새로운 객체로 교체
  - 그리고 해당 컴포넌트를 다시 렌더링

<br>

## 전개 문법으로 객체 복사

- 예를 들어 폼에서 단 한 개의 필드만 수정하고, 나머지 모든 필드는 이전 값을 유지하고 싶을 수도 있음
- 아래 코드의 input 필드는 `onChange` 핸들러가 state를 변경하기 때문에 동작하지 않음

```jsx
import { useState } from 'react';

export default function Form() {
  const [person, setPerson] = useState({
    firstName: 'Barbara',
    lastName: 'Hepworth',
    email: 'bhepworth@sculpture.com'
  });

  function handleFirstNameChange(e) {
    person.firstName = e.target.value;
  }

  function handleLastNameChange(e) {
    person.lastName = e.target.value;
  }

  function handleEmailChange(e) {
    person.email = e.target.value;
  }

  return (
    <>
      <label>
        First name:
        <input
          value={person.firstName}
          onChange={handleFirstNameChange}
        />
      </label>
      <label>
        Last name:
        <input
          value={person.lastName}
          onChange={handleLastNameChange}
        />
      </label>
      <label>
        Email:
        <input
          value={person.email}
          onChange={handleEmailChange}
        />
      </label>
      <p>
        {person.firstName}{' '}
        {person.lastName}{' '}
        ({person.email})
      </p>
    </>
  );
}
```

- 위 코드 또한 객체의 state를 변경하기 때문에 작동하지 않음
- 원하는 동작을 정확히 얻기 위해서 `setPerson`으로 전달해야 함

```jsx
setPerson({
    firstName: e.target.value,
    lastName: person.lastName,
    email: person.email
});
```

- `...` **객체 전개 구문**을 사용하면 모든 프로퍼티를 각각 복사하지 않아도 됨

```jsx
setPerson({
    ...person,  // 이전 필드 복사
    firstName: e.target.value   // 새로운 부분을 덮어쓰기
});
```

```jsx
import { useState } from 'react';

export default function Form() {
  const [person, setPerson] = useState({
    firstName: 'Barbara',
    lastName: 'Hepworth',
    email: 'bhepworth@sculpture.com'
  });

  function handleFirstNameChange(e) {
    setPerson({
      ...person,
      firstName: e.target.value
    });
  }

  function handleLastNameChange(e) {
    setPerson({
      ...person,
      lastName: e.target.value
    });
  }

  function handleEmailChange(e) {
    setPerson({
      ...person,
      email: e.target.value
    });
  }

  return (
    <>
      <label>
        First name:
        <input
          value={person.firstName}
          onChange={handleFirstNameChange}
        />
      </label>
      <label>
        Last name:
        <input
          value={person.lastName}
          onChange={handleLastNameChange}
        />
      </label>
      <label>
        Email:
        <input
          value={person.email}
          onChange={handleEmailChange}
        />
      </label>
      <p>
        {person.firstName}{' '}
        {person.lastName}{' '}
        ({person.email})
      </p>
    </>
  );
}
```

<br>