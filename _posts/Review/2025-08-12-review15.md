---
layout: post
title: 배열 State 업데이트하기
date: 2025-08-12 09:00 +09:00
categories: [React_re, adding Interactivity]
tags: [react]
image:
    path: /assets/img/react/React.png
---

## 변경하지 않고 배열 업데이트하기

- React state에서 배열은 읽기 전용으로 처리해야 함
- 즉, `arr[0] = 'bird'` 처럼 배열 내부의 항목을 재할당해서는 안되면 `push()`나 `pop()`같은 함수 배열을 변경해서는 안됨

- 대시 배열을 업데이트할 때마다 새배열을 state 설정 함수에 전달해야 함
- 이를 위해 state의 원본 배열을 변경시키지 않는 `filter()`와 `map()` 같은 함수를 사용하여 원본 배열로부터 새 배열을 만들 수 있음

|| 비선호(배열을 변경) | 선호(새 배열을 반환) |
|-|-|-|
| 추가 | `push`, `unshift` | `concat`, `[...arr]` 전개 연산자 |
| 제거 | `pop`, `shift`, `splice` | `filter`, `slice` |
| 교체 | `splice`, `arr[i] = ...` 할당 | `map` |
| 정렬 | `reverse`, `sort` | 배열을 복사한 이후 처리 |

<br>

> 주의!
>
> `slice`와 `splice` 함수는 이름이 비슷하지만 몹시 다름
>
> - `slice`를 사용하면 배열 또는 그 일부를 복사할 수 있음
> - `splice`는 배열을 변경 (항목을 추가하거나 제거)

<br>

## 배열에 항목 추가하기

- `push()`는 배열을 변경(원치 않는 방식)

```jsx
import { useState } from 'react';

let nextId = 0;

export default function List() {
    const [name, setName] = useState('');
    const [artists, setArtists] = useState([]);

    return (
        <>
            <h1>Inspiring sculptors:</h1>
            <input
                value={name}
                onChange={e => setName(e.target.value)}
            />
            <button onClick={() => {
                artists.push({
                id: nextId++,
                name: name,
                });
            }}>Add</button>
            <ul>
                {artists.map(artist => (
                <li key={artist.id}>{artist.name}</li>
                ))}
            </ul>
        </>
    )
}
```

- 여기서 가장 쉬운방법은 `...` **배열 전개 구문**을 사용하는 것

```jsx
setArtists(     // 아래의 새로운 배열로 state를 변경
    [
        ...artists, // 기존 배열의 모든 항목에,
        { id: nextId++, name: name }    // 마지막에 새 항목을 추가
    ]
);
```

> 배열 전개 구문을 사용하여 기존 배열인 `...artists`의 앞에 항목을 배치하여 추가할 수도 있음

<br>

## 배열에서 항목 제거하기

- 배열에서 항목을 제거하는 가장 쉬운 방법은 필터링하는 것
- 해당 항목을 포함하지 않는 새 배열을 제공

<br>

## 배열 변환하기

- 배열의 일부 또는 전체 항목을 변경하고자 한다면, `map()`을 사용해 새로운 배열을 만들 수 있음
- `map`에 전달할 함수는 데이터나 인덱스를 기반으로 각 항목을 어떻게 처리할지 결정할 수 있음

```jsx
import { useState } from 'react';

let initialShapes = [
  { id: 0, type: 'circle', x: 50, y: 100 },
  { id: 1, type: 'square', x: 150, y: 100 },
  { id: 2, type: 'circle', x: 250, y: 100 },
];

export default function ShapeEditor() {
  const [shapes, setShapes] = useState(
    initialShapes
  );

  function handleClick() {
    const nextShapes = shapes.map(shape => {
      if (shape.type === 'square') {
        // 변경시키지 않고 반환합니다.
        return shape;
      } else {
        // 50px 아래로 이동한 새로운 원을 반환합니다.
        return {
          ...shape,
          y: shape.y + 50,
        };
      }
    });
    // 새로운 배열로 리렌더링합니다.
    setShapes(nextShapes);
  }

  return (
    <>
      <button onClick={handleClick}>
        Move circles down!
      </button>
      {shapes.map(shape => (
        <div style={{
          background: 'purple',
          position: 'absolute',
          left: shape.x,
          top: shape.y,
          borderRadius:
            shape.type === 'circle'
              ? '50%' : '',
          width: 20,
          height: 20,
        }} />
      ))}
    </>
  );
}
```