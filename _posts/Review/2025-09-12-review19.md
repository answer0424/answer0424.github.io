---
layout: post
title: 프로젝트 개발 이후
date: 2025-09-12 09:00 +09:00
categories: [project, new_car]
tags: [project]
---

## 레이어드 아키텍처 구조

- Controller
    - 클라이언트에서 들어오는 요청을 제일 먼저 받는 진입점
- Request(DTO)
    - 클라이언트 ➡️ 서버 방향의 데이터 전달 객체
    - 보통 Controller에서 HTTP 요청을 Body에 매핑할 때 사용
    - 유효성 검사(Validation)를 붙이는 경우가 많음
- Response(DTO)
    - 서버 ➡️ 클라이언트 방향의 데이터 전달 객체
    - DB 엔티티를 그대로 노출하지 않고, 필요한 데이터만 선별해 가공
- Dao
    - DB와 직접 통신하는 계층
    - SQL을 실행하거나 ORM(JPA, MyBatis)를 통해 데이터를 조회/저장/수정/삭제
    - 오직 데이터 액세스만 책임짐
- Model(Domain/Entity)
    - 실제 비즈니스 개체(Entity)를 표현하는 클래스
    - DB 테이블과 매핑되거나, 순수 비즈니스 로직을 담는 객체
    - JPA `@Entity` 클래스에 해당하기도 함
- Command
    - 무언가를 실행하는 요청 정보를 담는 객체
    - 보통 CUD(Create, Update, Delete) 작업에 사용
    - Request DTO와 유사하지만 더 도메인 로직 중심적
- Query
    - 조회(Read) 요청 정보를 담는 객체
    - 보통 검색 조건이나 페이징 같은 조회 조건을 캡슐화
    - 복잡한 조회 조건을 하나의 객체로 정리해서 DAO/Repository로 전달
- Service
    - 비즈니스 로직을 담당하는 계층
    - Controller에서 받은 요청을 처리하고 DAO를 통해 DB를 조회하거나 외부 API를 호출하여 데이터를 가공
    - 단순 CRUD를 넘어 업무 규칙을 정의

## CQRS 패턴

- 개념
    - 전통적인 구조에서는 CRUD(Create, Read, Update, Delete)가 한 서비스/리포지토리 계층에서 모두 처리됨
    - 하지만 CQRS는 `Command` (쓰기/변경)와 `Query`(읽기/조회)를 완전히 분리
- CQRS 구조 흐름
    - Command 요청 흐름
        - 클라이언트가 ‘회원가입’, ‘비밀번호 변경’같은 명령을 실행
        - Command Handler에서 비즈니스 로직 처리
        - DB 쓰기 저장소에 반영
    - Query 요청 흐름
        - 클라이언트가 ‘회원 정보 조회’, ‘게시판 목록 보기’ 같은 조회 실행
        - Query Handler에서 최적화된 조회 로직 실행
        - DB 읽기 저장소에서 데이터 반환
- 특징
    - 관심사 분리(Separation of Concerns)
        - 읽기와 쓰기를 분리하여 코드가 단순해지고 유지보수성이 향상
    - 확장성(Scalability)
        - 조회 요청(Query)은 트래픽이 많을 수 있으므로 별도 DB로 분리해서 확장 가능
    - 데이터 모델 최적화
        - Command 모델: 비즈니스 규칙 중심으로 설계
        - Query 모델: 화면 출력/리포트 중심으로 설계