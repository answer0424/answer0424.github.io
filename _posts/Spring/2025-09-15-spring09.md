---
layout: post
title: Method Injection
date: 2025-09-15 13:00 +09:00
categories: [Spring, IoC Container(dependency)]
tags: [spring]
image:
    path: /assets/img/spring/Spring.png
---

## Method Injection

- Spring IoC 컨테이너에서 빈(bean)의 스코프(lifecycle)가 서로 다를 떄 생기는 문제를 해결하는 방법 중 하나
- 특히, 싱글톤(singleton) 빈이 프로토 타입(prototype) 빈을 매번 새로 생성해야 할 경우가 대표적
- 보통 싱글톤 빈은 애플리케이션 시작 시 한 번 생성되고, 그 안의 프로퍼티는 한 번만 주입

<br>

## 주요 형태들

| 방식 | 설명 | 특징/제한 |
|-|-|-|
| Lookup Method Injection | 빈 내에서 특정 메소드를 컨테이너가 override하거나 동적으로 서브클래싱 하여 호출 시마다 빈을 새로 lookup 하도록 함 | <ul><li>오버라이드할 메소드가 final이어선 안 됨.</li><li>해당 빈 클래스가 final이면 subclass 만들 수 없으므로 안 됨.</li><li>XML 기반 설정이나 @Lookup 어노테이션 사용 가능.</li><li>@Bean 메소드로 정의된 configuration 클래스에서는 method lookup이 불가한 경우 있음. Home </li><li>프로토타입 빈이 필요한 경우에 사용해야 함. 싱글톤 빈만 정의했다면 매번 새 인스턴스 안 나옴 </li></ul> | 
| Method Replacement/Arbitrary Method Injection | XML 설정에서 `<replaced-method>` 요소를 사용하여 기존 클래스의 특정 메소드를 다른 구현체로 바꿀 수 있음 | <ul><li>실제 사용 빈도가 낮음.</li><li>적당한 경우에만 사용; 복잡성을 높일 수 있음.</li><li>메소드 서명이 오버로딩(overloading)된 경우 인자 타입(arg-type)을 지정해줘야 함.</li></ul> |

<br>

## 예제: Lookup Method Injection (XML 설정 기준)

```xml
<bean id="myCommand" class="com.example.Command" scope="prototype">
    <!-- 프로토타입 빈 정의 -->
</bean>
<bean id="commandManager" class="com.example.CommandManager">
    <lookup-method name="createCommand" bean="myCommand"/>
</bean>
```

- `CommandManager` 클래스에 `createCommand()` 라는 메소드가 있고, 이 메소드를 호출할 때마다 `myCommand` 빈(prototype)을 새로 가져오도록 BeanFactory가 override / subclassing해서 구현됨

<br>

## 예제: `@Lookup` 어노테이션 사용(자바 기반 설정)

```java
public abstract class CommandManager{
    public Object process(Object commandState) {
        Command command = createCommand();
        // 상태 설정 등
        command.setState(commandState);
        return command.execute();
    }

    @Lookup("myCommand")
    protected abstract Command createCommand();
}
```

- `CommandManager`는 abstract 메소드 `createCommand()`를 가지고 있고, Spring 컨테이너가 이를 동적으로 구현

<br>

## 주의사항 / 한계

- 클래스나 메소드가 final이면 lookup method injection이 작동하지 않음 - Spring이 subclass를 만들 수 없기 때문
- `@Bean` 메소드 기반으로 configuration 클래스에서 정의된 빈에서는 method lookup이 제한적일 수 있음
- 문서에는 factory methods에서 동적 subclassing을 할 수 없는 경우 있음이라는 언급이 있음


<br>

## 사용 시기

- 싱글톤 빈이 존재, 이 싱글톤 빈이 내부에서 매번 새로 생성된 인스턴스가 필요한 상태와 협업해야 할 때
- 코드 의존성을 낮추고 싶을 때: `ApplicationContext` 직접 참조하지 않고 `@Lookup` 같은 메커니즘을 사용하면 더 깔끔
- 특정 메소드 호출 시마다 상태ful 객체가 필요할 때