---
layout: post
title: 선언적 트랜잭션 구현의 예
date: 2025-09-19 09:00:00 +09:00
categories: [Spring, DataAccess, Transaction Management, Declarative Transaction Management]
tags: [spring]
image:
    path: /assets/img/spring/Spring.png
---

## 개요

- `FooService`라는 서비스 인터페이스와 그 구현체 `DefaultFooService`를 사용해서 메서드 별로 트랜잭션의 읽기 전용 또는 읽기쓰기 트랜잭션을 선언적으로 지정함
- context.xml 설정을 통해 트랜잭션 `tx:advice`를 정의하고 서비스 빈에 트랜잭션 프록시를 생성해서 트랜잭션이 적요되도록 함

<br>

## 예제 구성 요소

| 요소 | 역할/설명 |
|-|-|
| `FooService` 인터페이스 | 트랜잭션을 적용할 메서드들의 선언(`getFoo`, `insertFoo`, `updateFoo`) |
| `DefaultFooService` 구현체 | 실제 동작하지만 예제로는 `UnsupportedOperationException`을 던져서 트랜잭이 롤백되는 동작을 테스트 |
| XML 설정 (`context.xml`) | `<tx:advice>` 태그로 트랜잭션 속성 지정: 메서드 이름이 "get"으로 시작하는 메서드는 `read-only` 트랜잭션 사용, 그 외 메서드는 기본 트랜잭션 사용 |
| `transaction-manager` 빈 | 트랜잭션을 실제 시작/커밋/롤백하는 역할을 할 `TransactionManager` 빈이 지정됨. 설정에서 `<tx:advice>`에 `transaction-manager="txManager"`같은 속성으로 참조 |
| AOP 설정 | 서비스 빈에 대해 트랜잭션 advice를 적용하기 위해 AOP 프록시를 생성하도록 설정. 서비스의 메서드 호출이 프록시를 통해 감싸져서 트랜잭션 구문이 실행 |

<br>

## 동작 흐름

1. application context가 XML 설정을 읽어서 빈들을 생성하고 트랜잭션 관련 설정을 처리
2. `FooService` 빈에 대해 트랜잭션 프록시가 생성 ➡️ 이 proxy는 service 구현체를 감싸서 서비스 메서드 호출 시 트랜잭션 advice가 끼어들 수 있게 함
3. 클라이언트가 `getFoo`같은 메서드를 호출하면 proxy가 먼저 동작하여 이 메서드가 read-only 트랜잭션으로 실행되도록 `TransactionManager`에게 트랜잭션을 시작함
4. 만약 `insertFoo`나 `updateFoo`같은 쓰기 작업이 수행되는 메서드동안 `UnsupportedOperationException`이 던져지면, 트랜잭션은 롤백

<br>

## 장단점

- 장점
  - 설정만으로 메서드별 트랜잭션 속성을 쉽게 제어 가능
  - 비즈니스 로직에 트랜잭션 관리 코드를 직접 넣을 필요 없음
  - 코드가 깔끔해지고 유지보수 쉬움
- 단점
  - XML 설정방식이라 코드량이 많고 가독성이 떨어질 수 있음 요즘은 `@Transaction` 방식으로 많이 사용
  - self-호출 등에 의해 트랜잭션 proxy가 적용되지 않는 경우가 있을 수 있음
  - 기본 롤백 규칙이 적절히 설정되어 있지 않으면 의도한 대로 롤백이 안될 수 있음
  

<br>

## 정리

> XML 기반 선언적 트랜잭션 설정으로 메서드 이름 패턴에 따라 읽기 전용 또는 읽기-쓰기 트랜잭션을 적용하고 예외 발생 시 롤백이 일어나도록 하는 구조를 보여줌

