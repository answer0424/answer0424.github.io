---
layout: post
title: TransactionalAspectJ와 함께 사용
date: 2025-09-22 09:00:00 +09:00
categories: [Spring, DataAccess, Transaction Management, Declarative Transaction Management]
tags: [spring]
image:
    path: /assets/img/spring/Spring.png
---

## 개요

- 보톤 `@Transactional`은 Spring AOP 프록시 기반으로 동작하는데, 때론 이 방식의 제약 때문에 AspectJ 방식으로 `@Transactional` 어노테이션을 사용하는 것이 유용
- `@Transactional` + AspectJ 조합해서 트랜잭션을 적용하는 방법을 설명

<br>

## 작동 방식 & 설정 방법

#### Annotation TransactionAspect 

- Spring에서 제공하는 AspectJ 기반 Aspect로, `spring-aspects.jar`안에 있음
- 이 Aspect는 `@Transactional`이 붙은 클래스나 메서드 호출을 감지하고 트랜잭션 시작/커밋/롤백을 수행

<br>

#### 트랜잭션 매니저 설정

- AspectJ 방식에서도 `TransactionManager`가 필요
- 예를 들어, `DataSourceTransactionManager` 등을 생성하고, `AnnontationTransactionAspect.aspectOf().setTransactionManager(txManager);`처럼 AspectJ Aspect 인스턴스에 주입해야 함

<br>

#### @Transactional 적용 범위

- 클래스에 붙이면 그 클래스의 모든 public 메서드가 기본적으로 그 클래스 어노테이션의 설정을 따름
- 메서드에 붙이면 그 메서드 설정이 클래스 설정보다 우선
- 인터페이스에는 붙어도 무시됨

<br>

#### 어노테이션 가시성

- AspectJ 방식에서는 메서드의 접근제어자에 상관없이 적용 가능
- 프록시 방식일 때는 보통 public 메서드에만 적용 가능했음

<br>

#### 위빙 방식

- 컴파일 타임 또는 로드 타임 방식 사용 가능
- 어플리케이션 AspectJ로 빌드하거나, 로드 타임 위버 설정해야 함

<br>

#### <tx:annotation-driven moda="aspectj"/>

- XML 기반 설정에서는 `<tx:annotation-driven moda="aspectj" .../>`처럼 mode를 `aspectj`로 지정하면 AspectJ 방식 트랜잭션에 필요한 설정이 활성화됨

<br>

## 장단점

- 장점
  - 내부 호출에서도 트랜잭션 적용 가능, 메서드 가시성이나 기타 제한 덜함
  - 보다 강력하고 유연한 방식으로 동작 제어 가능
- 단점
  - 빌드 복잡성 증가: AspectJ 컴파일/위버 설정 필요, `spring-aspects.jar` 필요
  - 런타임에 instrumentation이나 위빙 설정이 올바르게 구성되어야 함
  - 디버깅이 약간 더 복잡할 수 있고 성능 오버에드도 조금 더 있을 수 있음


<br>

## 정리

> `@Transactional with AspectJ`는 Spring AOP 프록시 방식의 제약을 넘어서 AspectJ의 위빙을 통해 `@Transactional`을 클래스나 메서드 단위에서 직접 적용하고 메서드 접근 제어자 제한없이 트랜잭션 경계를 제어할 수 있게 해주는 방식