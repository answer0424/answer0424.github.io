---
layout: post
title: 컨텍스트 계층 구조
date: 2025-09-24 09:00:00 +09:00
categories: [Spring, Servlet Stack, Web MVC, DispatcherServlet]
tags: [spring]
image:
    path: /assets/img/spring/Spring.png
---

## Context 계층이란

- `DispatcherServlet`은 `WebApplicationContext`를 기대함. 이 `WebApplicationContext`는 연결된 `ServletContext` 및 해당 `Servlet`과 연관
- 보통 하나의 `WebApplicationContext`만 사용해도 충분하지만, 여러 `DispatcherServlet` 인스턴스를 사용하는 복잡한 웹 어플리케이션에서는 context 계층 구조를 구성할 수 있음
- 루트 `WebApplicationContext`가 공통 인프라 빈을 갖고, 각 Servlet별 하위 `WebApplicationContext`가 개별 기능 설정을 담당
- 루트 컨텍스트는 여러 Servlet 인스턴스 간 공유되는 인프라를 보관하고, 자식 컨텍스는 Servlet 특화 빈을 선언
- 자식은 루트 컨텍스트의 빈을 상속하지만 필요시 동일 이름의 빈을 오버라이드할 수 있음

![alt text](../../assets/img/spring/spring_58_01.png)

<br>

## 예제 구성 방식

- Java 설정 방식(Annotation 기반)
  - `AbstractAnnotationConfigDispatcherServletInitializer`를 상속하여 `getRootConfigClasses()`와 `getServletConfigClasses()`를 오버라이드 함
  - `getRootConfigClasses()` 로트 컨텍스트 설정 클래스를 반환하고, `getServletConfigClasses()`는 해당 `DispatcherServlet`에 대한 서블릿 전용 설정 클래스를 반환
  - 만약 context 계층이 불필요하다면, `getServletConfigClasses()`에서 `null`을 반환하고 모든 설정을 루트 컨텍스트에 몰아서 할 수 있음
- web.xml 기반 구성 방식(XML 설정 방식)
  - `<listener>` 태그로 `ContextLoaderListener`를 정의하고, `<context-param>`으로 루트 컨텍스트 설정 파일 위치(`root-context.xml`) 지정
  - `<servlet>` 태그로 `DispatcherServlet`을 정의하고 `contextConfigLocation` 초기화 파라미터로 servlet 전용 설정 파일(app1-context.xml) 지정
  - 만약 컨텍스트 계층이 필요 없으면, Servlet의 `contextConfigLocation`은 비워둘 수 있음

<br>

## 계층 구조의 장점 / 역할 분리

- 공통 기능 및 인프라 빈을 루트 컨텍스트에 모아두면, 여러 Servlet에서 공유 가능
- Servlet별로 다르게 동작해야 할 웹 계층 설정은 자식 컨텍스트에 정의
- 자식 컨텍스트는 루트의 빈을 읽을 수 있지만, 루트의 설정을 강제로 덮어쓸 수도 있음(오버라이드 가능)
- 구조가 명확해지고 관심 분리가 쉬워지며, 확장성과 모듈화에 유리

<br>

## 어노테이션 정리

- @Configuration: Java 기반 설정 클래스로서 빈 구성 정의에 사용
- @EnableWebMvc: Spring MVC 설정을 활성화하여 기본 MVC 구성을 적용
- @ComponentScan: 특정 패키지 내에서 `@Controller`, `@Service` 등 컴포넌트 클래스를 검색하여 빈으로 등록
- @Bean: 메서드 수준에서 빈 객체를 생성하고 Spring 컨테이너에 등록하도록 지정
- @Controller: 웹 요청을 처리하는 컨트롤러 클래스를 나타냄
- @RequestMapping: HTTP 요청 경로에 매핑되어 해당 메서드를 실행하도록 연결