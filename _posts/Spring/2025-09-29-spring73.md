---
layout: post
title: Declaration
date: 2025-09-29 09:00:00 +09:00
categories: [Spring, Servlet Stack, Web MVC, Controller]
tags: [spring]
image:
    path: /assets/img/spring/Spring.png
---

## 주요 내용

#### 컨트롤러 빈 선언 방식

- 컨트롤러 빈으로 등록하는 방식은 보통 Spring의 일반 빈 선언 방식과 동일 - XML 설정, Java Config에서 `@Bean` 선언 등
- 다만 `@Controller` 스테레오타입을 사용하면 컴포넌트 스캔 시 자동 탐지 가능

```java
@Configuration
@ComponentScan("org.example.web")
public class WebConfiguration {
    // ...
}
```

```xml
<context:component-scan base-package="org.example.web"/>
```

<br>

#### `@RestController`와 `@Controller` 차이

- `@RestController`는 `@Controller` + `@ResponseBody`를 조합한 메타 어노테이션
- 즉, 클래스에 붙이면 해당 클래스의 모든 메서드가 기본적으로 `@ResponseBody`가 적용된 것처럼 동작
- 뷰를 렌더링하는 게 아니라 HTTP 응답 본문에 직접 쓰는 방식으로 동작
- RESTful API 응답을 JSON, XML 등 형태로 반환할 때 `@RestController`를 주로 사용

<br>

#### AOP 프록시 적용 시 고려사항

- 만약 컨트롤러 클래스에 `@Transactional` 같은 어노테이션을 붙이는 등 AOP 프록시가 필요할 경우 클래스 기반 프록시를 사용하는 게 좋음
- 이유: 기본적으로 Spring은 인터페이스 기반 프록시를 사용하려고 하는데, 6.0 버전 이후부터는 인터페이스에만 `@RequestMapping`이 붙은 경우 해당 인터페이스만으로는 컨트롤러로 인식되지 않을 수 있음
- 따라서, 만약 컨트롤러가 인터페이스를 구현하고 있고 그 인터페이스에 `@RequestMapping`을 붙였다면 클래스 기반 프록시(proxyTargetClass=true) 설정을 해줘야 제대로 동작
  - `@EnableTransactionManagement(proxyTargetClass = true)`
  - XML 사용 시 `<tx:annotation-driven proxy-target-class="true"/>`

<br>

## 핵심 요약

> 어노테이션 기반 컨트롤러 선언 방식에 맞춰 초점을 맞춰, `@Controller` / `@RestController` 빈 등록 방식, 자동 탐지 설정, AOP 프록시 적용 시 주의사항 등을 설명하고 있음

- @Controller ➡️ 해당 클래스를 Spring MVC 컨트롤러 빈으로 선언하고, 컴포넌트 스캔 대상이 되게 함
- @RestController ➡️ `@Controller` + `@ResponseBody` 결합, 메서드의 반환을 뷰 렌더링 없이 응답 본문으로 직렬화
- @ComponentScan ➡️ 지정한 패키지 내의 `@Controller` 등 컨포넌트 어노테이션 클래스들을 자동 감지하여 빈으로 등록
- proxyTargetClass=true 설정 ➡️ AOP 프록시가 필요한 경우 클래스 기반 프록시 방식을 가제로 사용하여 컨트롤러 인식 문제 회피