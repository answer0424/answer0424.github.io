---
layout: post
title: Mapping Requests
date: 2025-09-30 09:00:00 +09:00
categories: [Spring, Servlet Stack, Web MVC, Annotated Controller]
tags: [spring]
image:
    path: /assets/img/spring/Spring.png
---

## 기본 개념 및 사용 위치

- `@RequestMapping` 어노테이션은 컨트롤러 메서드를 HTTP 요청과 매핑시키는 역할
- 클래스 레벨에도 붙여서 공통 경로를 선언할 수 있고, 메서드 레벨에서는 더 구체적인 매핑을 지정할 수 있음
- `@GetMapping`, `@PostMapping`, `@PutMapping`, `@DeleteMapping`, `@PatchMapping` 등의 HTTP 메서드 전용 축약 어노테이션들도 사용 가능
- 내부적으로 `@RequestMapping`의 특수화 버전
- 한 요소에 `@RequestMapping`을 여러 개 같이 사용 할 수 없음
- 여러 개 붙이면 경고가 발생하고 첫번째 것만 적용

<br>

## URI 패턴 / 경로 매칭 방식

- Spring MVC에서는 두 가지 경로 매칭 모드가 있음
    1. PathPattern ➡️ 요청 경로를 미리 파싱된 형태로 처리, 인코딩/경로 파라미터 처리에 유리
    2. AntPathMatcher ➡️ 문자열 패턴 매칭 방식
- `PathPattern`은 기존 `AntPathMatcher` 구문과 대부분 호환되지만, `*`, `**`, `{var}` 등의 패턴 사용법이 약간 다름
- 예시 경로 패턴
  - `/resources/*.png`
  - `/resources/**`
  - `/projects/{project}/versions`
  - `/projects/{project:[a-z]+}/versions`
- 클래스 수준과 메서드 수준 모두 URI 변수를 선언할 수 있고, 이는 `@PathVariable`로 바인딩 가능

<br>

## 요청 조건 좁히기

> `@RequestMapping`에는 여러 속성이 있어서, 단순 경로 매핑 이상으로 요청 조건을 세밀하게 제어 가능

| 속성 | 역할/예시 |
|-|-|
| consumes | 요청의 `Content-Type` 헤더 기준으로 매핑 |
| produces | 응답할 미디어 타입 제한 |
| params | 요청 파라미터 조건 |
|  headers | 요청 헤더 조건 |

- `consumes`, `produces` 속성은 클래스 레벨과 메서드 레벨 둘 다 사용 가능하지만, 메서드 레벨이 클래스 레벨 선언을 덮어써야 함
- `@RequestMapping`은 기본적으로 HTTP 메서드 제한을 명시하지 않으면 모든 메서드를 매핑 대상으로 삼음
- 하지만 명시하지 않을 경우 `Allow` 응답 헤더 등을 자동으로 처리
- `HEAD` 요청은 `@GetMapping`이나 `@RequestMapping(method = RequestMethod.GET)` 방식이 자동으로 처리됨
- `OPTIONS` 요청의 경우 기본적으로 매핑된 메서드들을 기준으로 `Allow` 헤더가 설정됨

<br>

## 우선순위 / 패턴 선택 규칙

- 여러 매핑이 동일한 URL과 조건에 걸릴 수 있을 때 가장 구체적인 패턴이 우선 선택
  - 패턴 구체성 판단 기준: URI 변수 개수, 와일드 카드 개수, 패턴 길이 등 기준으로 비교됨
- 기본 패턴인 `/**` 같은 와일드카드 전체 매핑은 우선순위에서 제일 낮게 평가됨

<br>

## 접미사(suffix) 매칭 및 보안 고려

- 과거에는 URL 접미사도 암묵적으로 매핑 대상이 됐지만, Spring 5.3부터는 기본적으로 이러한 "suffix 매칭"이 비활성화됨
- 접미사 매칭이 허용되면 보안상 RFD(Reflected File Download) 공격 위험이 커질 수 있어서, 기본적으로 꺼져 있는 게 권장
- 만약 접미사 매칭을 사용하고 싶다면, `useSuffixPatternMatching(false)` 또는 `favorPathExtension(false)` 같은 설정을 조정해야 함

<br>

## 명시적 핸들러 메서드 등록

- `RequestMappingHandlerMapping`을 통해 런타임에 핸들러 메서드를 프로그래밍 방식으로 등록할 수 있음
- `@RequestMapping`을 메타 어노테이션 형태로 커스텀 어노테이션으로 재구성하는 것도 가능

```java
@RequestMappingInfo info = RequestMappingInfo
    .paths("/custom")
    .methods(RequestMethod.GET)
    .build();
Method method = MyController.class.getMethod("myHandlerMethod");
handlerMapping.registerMapping(info, myControllerInstance, method);
```

<br>

## 요약

> `@RequestMapping` 및 그 축약 어노테이션들은 URL 경로, HTTP 메서드, 요청/응답 미디어 타입, 파라미터/헤더 조건 등을 세밀하게 지정하여 요청을 컨트롤러 메서드와 매핑할 수 있게 해주며, Spring MVC는 패턴 매핑 알고리즘과 우선순위 규칙을 통해 적합한 매핑을 선택

