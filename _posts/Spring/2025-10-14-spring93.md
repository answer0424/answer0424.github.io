---
layout: post
title: Functional Endpoints
date: 2025-10-14 09:00:00 +09:00
categories: [Spring, Servlet Stack, Web MVC]
tags: [spring]
image:
    path: /assets/img/spring/Spring.png
---

## 개요

- Spring MVC는 전통적인 어노테이션 기반 방식 외에도 함수형 엔드포인트 스타일을 지원
- 이 함수형 방식은 WebMvc.fn 패키지 하에 정의되어 있으며, 함수와 불변 개념을 중심으로 설계된 경량화된 프로그래밍 모델
- 기존 `DispatcherServlet` 기반의 처리 흐름과 통합되어 동작하므로, 어노테이션 방식과 함께 혼용할 수도 있음

<br>

## HandlerFunction & ServerRequest / ServerResponse

- `HandlerFunction<ServerResponse>`: 요청을 처리하는 함수. `ServerRequest`를 인자로 받아 `ServerResponse`를 반환
- `ServerRequest`: HTTP 요청을 표현하는 읽기용 객체로, URL, 헤더, 쿼리파라미터, 바디 등의 접근 메서드를 제공
- `ServerResponse`: HTTP 응답을 표현하는 객체로, 상태 코드, 헤더, 바디를 설정할 수 있는 빌더 API를 제공

```java
HandlerFunction<ServerResponse> hello = 
    request -> ServerResponse.ok().body("Hello, World!");
```

<br>

## RouterFunction & RequestPredicates

- `RouterFunction<ServerResponse>`: 라우팅 규칙을 표현하는 객체. `ServerRequest`를 받아 `Optional<HandlerFunction>`을 반환하는 함수
- `RouterFunctions.route()` 빌더를 사용하여 여러 경로와 핸들러 매핑을 선언할 수 있음
- `RequestPredicates`: HTTP 메서드, 경로, 헤더, 미디어 타입 등 조건을 표현하는 여러 `RequestPredicate` 유틸리티가 제공됨

```java
RouterFunction<ServerResponse> route = route()
    .GET("/person/{id}", accept(APPLICATION_JSON), handler::getPerson)
    .GET("/person", accept(APPLICATION_JSON), handler::listPeople)
    .POST("/person", handler::createPerson)
    .build();
```

- 중첩된 라우팅도 지원됨

<br>

## 본문 바인딩 / 요청 처리

- `ServerRequest.body(...)` 메서드를 사용하여 요청 본문을 특정 타입으로 변환할 수 있음
- 제네릭 타입 바인딩도 가능
- 요청 파라미터, 경로 변수, 쿼리 파라미터, 바인딩 기능들도 제공

```java
Pet pet = request.bind(Pet.classm dataBinder -> dataBinder.setAllowFields("name"));
```

<br>

## 응답 생성

- `ServerResponse.ok().body(ob)`처럼 본문과 상태, 콘텐츠 타입을 설정하여 응답을 생성할 수 있음
- `ServerResponse.created(loaation).build()`처럼 상태 코드만 설정하거나 헤더만 설정한 응답도 가능
- 비동기 응답(`CompletableFuture`, `Publisher`, `Mono`)을 본문으로 지정할 수 있으며, 이를 `ServerResponse.async(..)` 등의 메서드로 처리할 수 있음
- Server-Sent Events 응답도 지원

<br>

## 유효성 검사

- 함수형 핸들러에서도 Spring의 `Validator` 인터페이스를 사용해 요청 본문 객체에 대해 검증할 수 있음
- 예: `BeanPropertyBindingResult`를 사용해 오류를 체크하고 오류가 있을 경우 `ServerWebInputException` 등 예외를 던져 400 응답을 유도하는 패턴이 있을 수 있음

<br>

## 필터 및 전처리 / 후처리

- 라우팅 빌더에 `before`, `after`, `filter` 메서드를 사용하여 요청/응답 전후 처리 로직을 삽입할 수 있음
- `filter` 메서드는 `HandlerFilterFunction` 타입의 인자를 받고, 요청 ➡️ 핸들러 ➡️ 응답 흐름을 직접 제어할 수 있게 해줌
- 이 방식으로 보안 검증, 로깅, 헤더 삽입/변환 등의 공통 처리 로직을 라우팅 함수 체인에 쉽게 끼울 수 있음

<br>

## 정적 리소스 처리 및 리디렉션

- `RouterFunctions.resource(...)` 또는 `RouterFunctions.resources(...)` 메서드를 사용하여 특정 경로에 대해 정적 리소스를 제공할 수 있음
- 예: SPA 처럼 `/api/**`가 아닌 요청을 `index.html`로 리디렉션하는 구성등이 가능

<br>

## 구성 및 실행

- `RouterFunction<?>` 빈을 `@Configuration` 클래스 내에 등록하면 Spring이 자동으로 감지하고, `RouterFunctionMapping`과 `HandlerAdapter` 같은 내부 컴포넌트를 통해 `DispatcherServlet` 흐름에 통합
- 즉, 함수형 엔드포인트는 어노테이션 기반 컨트롤러와 공존 가능하며, Spring Boot Web 스타터를 사용할 때 기본적으로 활성화될 수 있음