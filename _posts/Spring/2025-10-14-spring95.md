---
layout: post
title: Asynchronous Requests
date: 2025-10-14 09:00:00 +09:00
categories: [Spring, Servlet Stack, Web MVC]
tags: [spring]
image:
    path: /assets/img/spring/Spring.png
---

## 개요

- Spring MVC는 Servlet 비동기 요청 처리를 광범위하게 통합해서 지원함
- 컨트롤러 메서드에서 반환 가능 유형: `DeferredResult`, `Callable`, `WebAsyncTask`를 사용하여 비동기 응답이 가능함
- 또한 여러 개의 비동기 값을 스트리밍 방식으로 응답할 때 `ResponseBodyEmitter`, `SseEmitter`, `StreamingResponseBody` 등을 사용 가능함
- Reactive 클라이언트를 사용하거나 리액티브 타입을 반환하는 경우에도 대응됨

<br>

## 주요 비동기 반환 타입과 사용법

#### `DeferredResult`

- 컨트롤러에서 `DeferredResult<T>`를 반환하면, 결과를 바로 반환하지 않고 나중에 어떤 다른 스레드나 이벤트에서 `setResult(...)`를 호출해서 응답을 채울 수 있음

```java
@GetMapping("/quotes")
@ResponseBody
public DeferredResult<String> quotes() {
    DeferredResult<String> result = new DeferredResult<>();
    // 비동기 작업 수행, 또는 이벤트에 응답 대기
    // ex: 다른 스레드에서 나중에 결과를 세팅
    return deferredResult;
}

// 다른 스레드에서:
result.setResult("some result");
```

<br>

#### `Callable`

- `Callable<V>` 반환값도 지원됨
- 컨트롤러가 반환하면 Spring은 이를 `AsyncTaskExecutor`에 제출하여 별도 스레드에서 실행하고 결과를 기다린 후 응답을 완성

```java
@PostMapping("/process")
public Callable<String> process() {
    return () -> {
        // 긴 처리 작업 수행
        Thread.sleep(2000);
        return "process complete";
    };
}
```

<br>

#### `ResponseBodyEmitter` / `SseEmitter`

- 여러 값을 순차적으로 클라이언트에게 스트리밍 방식으로 응답할 때 사용
- `REsponseBodyEmitter emitter = new ResponseBodyEmitter();`를 반환하곻 다른 스레드에서 `emitter.send(...)`, `emitter.complete()` 등을 호출함
- `SseEmitter`는 SSE를 지원하는 전용 클래스

<br>

#### `StreamingResponseBody`

- `StreamingResponseBody`는 응답의 `OutputStream`에 직접 데이터를 기록할 수 있는 방식

<br>

## 비동기 요청 처리 흐름

- Servlet 컨테이너의 비동기 처리가 활성화되어야 함
- Spring MVC 설정에서는 `WebMvcConfigurer`의 `configureAsyncSupport(..)` 메서드를 통해 타임아웃, `AsyncTaskExecutor`, 인터셉터 등을 설정 가능함
- 예: `DeferredResult`나 `SseEmitter` 등에 타임아웃을 설정할 수 있으며, `WebAsyncTask`를 사용하면 `Callable`에 대한 타임아웃 제어 가능함

<br>

## 예외 처리 및 주의 사항

- `DeferredResult` 반환 시, `setResult(..)`외에 `setErrorResult(...)`를 통해 예외를 설정할 수 있음
- 스트리밍 중 클라이언트 연결이 끊어지는 등의 상황에서 자동으로 에러 처리와 연결 종료 처리가 이루어짐
- 리액티브 타입 반환 시에도 비동기 스트림 처리가 가능하지만, 실제 쓰기는 별도 스레드에서 블록킹 방식으로 수행됨

<br>

## 예제

```java
@RestController
public class AsyncController {
    @GetMapping("/quote")
    public DeferredResult<String> getQuote() {
        DeferredResult<String> dr = new DeferredResult<>();

        // 비동기 작업
        new Thread(() -> {
            try {
                Thread.sleep(2000);
                dr.setResult("Delayed Quote");
            } catch (InterruptedException e) {
                dr.setErrorResult(e);
            }
        }).start();
        return dr;
    }

    @GetMapping("/stream-sse")
    public SseEmitter streamEvents() {
        SseEmitter emitter = new SseEmitter();

        new Thread(() -> {
            try {
                for (int i = 0; i < 5; i++) {
                    emitter.send("Event #" + i);
                    Thread.sleep(1000);
                }
                emitter.complete();
            } catch (Exception e) {
                emitter.completeWithError(e);
            }
        }).start();

        return emitter;
    }

    @GetMapping("/stream-download")
    public StreamingResponseBody download() {
        return outputStream -> {
            for (int i = 0; i < 10; i++) {
                outputStream.write(("Chunk " + i + "\n").getBytes());
                outputStream.flush();
                Thread.sleep(500);
            }
        };
    }
}
```