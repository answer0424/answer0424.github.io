---
layout: post
title: Overview
date: 2025-10-22 09:00:00 +09:00
categories: [Spring, Servlet Stack, Web MVC, WebSockets, STOMP]
tags: [spring]
image:
    path: /assets/img/spring/Spring.png
---


## STOMP over WebSocket 개요

- WebSocket 프로토콜은 텍스트/바이너리 메시지를 주고 받을 수 있는 양방향 통신 채널을 제공하지만 이 자체로는 메시지의 의미나 라우팅 등에 대해 정의하지 않음
- 따라서 WebSocket 위에 메시징 프로토콜을 얹어서 클라이언트 ↔️ 서버 간의 메시지를 어떤 형식으로 어디에 보내는지 등을 정의하는 것이 일반적
  - 그 중 하나가 STOMP (Simple Text Oriented Messaging Protocol)
- STOMP는 웹소켓 위에서 작동하는 고수준 프로토콜로 "CONNECT", "SEND", "SUBSCRIBE", "UNSUBSCRIBE", "MESSAGE" 같은 명령어를 정의하고 있어 메시지 브로커 패턴(pub/sub)을 손쉽게 구현 가능

<br>

## Spring에서의 STOMP 지원 구조

- Spring은 `spring-websocket`, `spring-messaging` 모듈을 통해 WebSocket + STOMP 를 통합 지원함
- 기본 흐름
  1. 클라이언트가 WebSocket 엔드포인트(`"/we"`)에 접속하여 WebSocket 핸드셰이크를 진행
  2. 핸드셰이크 과정에서 클라이언트와 서버가 `Sec-WebSocket-Protocol` 헤더 등을 통해 STOMP를 서브프로토콜로 선택
  3. WebSocket 연결이 확립되면 STOMP 프레임을 통해 `SEND`, `SUBSCRIBE`  등의 메시지를 주고 받음
  4. 서버 측에서는 `@MessageMapping`등이 붙은 메서드가 STOMP 목적지를 기반으로 메시지를 핸들링하고 메시지 브로커로부터 구독에 따라 클라이언트로 메시지를 전달

```java
@Configuration
@EnableWebSocketMessageBroker
public class WebSocketConfig implements WebSocketMessageBrokerConfigurer {
    @Override
    public void registerStompEndpoints(StompEndpointRegistry registry) {
        registry.addEndpoint("/ws")
                .setAllowedOrigins("*")
                .withSockJS(); // SockJS 폴백 지원
    }

    @Override
    public void configureMessageBroker(MessageBrokerRegistry config) {
        config.enableSimpleBroker("/topic", "/queue"); // 간단한 메모리 기반 브로커 활성화
        config.setApplicationDestinationPrefixes("/app"); // 클라이언트가 메시지를 보낼 때 사용하는 접두사
        config.setUserDestinationPrefix("/user"); // 사용자별 메시지 접두사\
    }
}
```

<br>

## 장점 및 활용 사례

- STOMP를 이용하면 WebSocket 위에서 구독/발행 메시징 모델을 손쉽게 구현할 수 있어, 채팅 앱, 알림 시스템, 협업 도구 등 실시간 양방향 통신이 필요한 어플리케이션에 적합
- STOMP는 메시지 헤더, 목적지, 구독 아이디 등을 명확히 정의하기 때문에, 단순 WebSocket보다 구조화된 메시징 시스템을 구축하기가 용이함
- SockJS 폴백과 함께 사용하면 WebSocket 미지원 환경에서도 안정적으로 메시징이 가능하다는 장점이 있음

<br>

## 유의사항

- STOMP/메시징 모델을 쓰는 경우, 메시지 브로커 선정 및 구성, 구독 관리, 최대 메시지 크기, 심장비 설정 등이 중요해짐
- WebSocket 환경에서 STOMP를 사용할 때는 초기 핸드셰이크, 서브프로토콜 선택, COR 설정, 보안 등을 꼼꼼히 고려해야 함
- 많은 메시지가 오가는 환경이라면 단순 WebSocket보다 STOMP 브로커를 통한 구조화된 메시징이 성능 - 유지보수 측명에서 유리할 수 있지만, 그만큼 설정 복잡도와 리소스가 증가할 수 있음