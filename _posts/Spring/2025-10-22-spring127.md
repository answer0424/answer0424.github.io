---
layout: post
title: Overview
date: 2025-10-22 09:00:00 +09:00
categories: [Spring, Servlet Stack, Web MVC, WebSockets, STOMP]
tags: [spring]
image:
    path: /assets/img/spring/Spring.png
---


## STOMP over WebSocket 개요

- WebSocket 프로토콜은 텍스트/바이너리 메시지를 주고 받을 수 있는 양방향 통신 채널을 제공하지만 이 자체로는 메시지의 의미나 라우팅 등에 대해 정의하지 않음
- 따라서 WebSocket 위에 메시징 프로토콜을 얹어서 클라이언트 ↔️ 서버 간의 메시지를 어떤 형식으로 어디에 보내는지 등을 정의하는 것이 일반적
  - 그 중 하나가 STOMP (Simple Text Oriented Messaging Protocol)
- STOMP는 웹소켓 위에서 작동하는 고수준 프로토콜로 "CONNECT", "SEND", "SUBSCRIBE", "UNSUBSCRIBE", "MESSAGE" 같은 명령어를 정의하고 있어 메시지 브로커 패턴(pub/sub)을 손쉽게 구현 가능

<br>

## Spring에서의 STOMP 지원 구조

- Spring은 `spring-websocket`, `spring-messaging` 모듈을 통해 WebSocket + STOMP 를 통합 지원함
- 기본 흐름
  1. 클라이언트가 WebSocket 엔드포인트(`"/we"`)에 접속하여 WebSocket 핸드셰이크를 진행
  2. 핸드셰이크 과정에서 클라이언트와 서버가 `Sec-WebSocket-Protocol` 헤더 등을 통해 STOMP를 서브프로토콜로 선택
  3. WebSocket 연결이 확립되면 STOMP 프레임을 통해 `SEND`, `SUBSCRIBE`  등의 메시지를 주고 받음
  4. 서버 측에서는 `@MessageMapping`등이 붙은 메서드가 STOMP 목적지를 기반으로 메시지를 핸들링하고 메시지 브로커로부터 구독에 따라 클라이언트로 메시지를 전달

```java
@Configuration
@EnableWebSocketMessageBroker
public class WebSocketConfig implements WebSocketMessageBrokerConfigurer {
    @Override
    public void registerStompEndpoints(StompEndpointRegistry registry) {
        registry.addEndpoint("/ws")
                .setAllowedOrigins("*")
                .withSockJS(); // SockJS 폴백 지원
    }

    @Override
    public void configureMessageBroker(MessageBrokerRegistry config) {
        config.enableSimpleBroker("/topic", "/queue"); // 간단한 메모리 기반 브로커 활성화
        config.setApplicationDestinationPrefixes("/app"); // 클라이언트가 메시지를 보낼 때 사용하는 접두사
        config.setUserDestinationPrefix("/user"); // 사용자별 메시지 접두사\
    }
}
```

<br>

