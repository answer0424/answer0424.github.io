---
layout: post
title: Token Authentication
date: 2025-10-24 09:00:00 +09:00
categories: [Spring, Servlet Stack, Web MVC, WebSockets, STOMP]
tags: [spring]
image:
    path: /assets/img/spring/Spring.png
---


## 개요

- 쿠키 기반 HTTP 세션 인증 방식은 대부분의 웹 어플리케이션에서 사용되어 왔고, Spring Security와 같이 동작
- 하지만 모바일 클라이언트, 별도 세션을 유지하지 않는 어플리케이션 또는 헤더 기반 인증을 선호하는 환경에서는 세션 인증 방식이 적합하지 않을 수 있음
- WebSocket 프로토콜은 핸드셰이크 시 인증 방법은 명시적으로 규정하지 않고 있기 때문에 브라우저 기반 클라이언트에서는 헤더 또는 토큰을 직접 전달하는 데 제약이 존재
- 따라서 STOMP over WebSocket 환경에서는 CONNECT 프레임 헤더에 토큰을 포함시키고 서버 측에서 이를 읽어 인증 후 `Principal`을 설정하는 방식이 권장

<br>

## 구현 방식 및 코드 예제

#### 1. 클라이언트에서 인증 헤더 포함

- STOMP 클라이언트에서 `CONNECT` 요청 시 헤더에 토큰을 포함함

```js
const header = {
    Authorization: "Bearer <your-jwt-token>"
};

stompClient.connect(headers, frame => {
    // connected
});
```

<br>

#### 2. 서버 측 인증 처리 - `ChannelInterceptor` 사용

- `@EnableWebSocketMessageBroker` 설정 클래스에서 `configureClientInboundChannel(..)` 메서드를 통해 채널 인터셉터를 등록

```java
@Configuration
@EnableWebSocketMessageBroker
public class WebSocketConfig implements WebSocketMessageBrokerConfigurer {
    @Override
    public void configureClientInboundChannel(ChannelRegistration registration) {
        registration.interceptors(new ChannelInterceptor() {
            @Override
            public Message<?> preSend(Message<?> message, MessageChannel channel) {
                StompHeaderAccessor accessor = MessageHeaderAccessor
                                              .getAccessor(message, StompHeaderAccessor.class);
                if (StompCommand.CONNECT.equals(accessor.getCommand())) {
                    String token = accessor.getFirstNativeHeader("Authorization");
                    // 토큰 검증 로직 수행
                    Authentication user = authenticateToken(token);
                    accessor.setUser(user);
                }
                return message;
            }
        });
    }
}
```

<br>

#### 주문 설정 우선순위

- Spring Security를 메시징 안정성 까지 적용하는 경우, 위 `ChannelInterceptor`가 Spring Security 관련 채널 인터셉터보다 먼저 동작하도록 순서를 지정해야 한다는 주의사항이 있음


<br>

## 유의사항 및 팁

- 브라우저/클라이언트 쪽 제약: SockJS 같은 경우 HTTP 헤더 전송이 제한적으므로, 쿼리 파라미터 방식으로 토큰을 넘기기도 하나 로그 기록 등에 유의해야 함
- 인증이 제대로 되면 `accessor.setUser(user)`를 통해 `Principal`이 STOMP 세션에 설정되고, 이후 메시지에서 사용자 기반 처리가 가능해짐
- 토큰 방식 인증을 도입할 경우, WebSocket 핸드셰이크/구독/발송 흐름에서 세션 기반 인증 방식과의 차이를 고려해야 함
- 메시지 브로커 등과 연계된 환경에서는 인증 후 구독 목적지나 사용자 목적지 처리 등에 인증 정보가 일관되게 적용되는지 확인이 필요
- 보안 측면에서 CSRF, CORS, Origin 체크 등이 WebSocket 환경에서도 고여되어야 함