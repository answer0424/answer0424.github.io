---
layout: post
title: Token Authentication
date: 2025-10-24 09:00:00 +09:00
categories: [Spring, Servlet Stack, Web MVC, WebSockets, STOMP]
tags: [spring]
image:
    path: /assets/img/spring/Spring.png
---


## 개요

- 쿠키 기반 HTTP 세션 인증 방식은 대부분의 웹 어플리케이션에서 사용되어 왔고, Spring Security와 같이 동작
- 하지만 모바일 클라이언트, 별도 세션을 유지하지 않는 어플리케이션 또는 헤더 기반 인증을 선호하는 환경에서는 세션 인증 방식이 적합하지 않을 수 있음
- WebSocket 프로토콜은 핸드셰이크 시 인증 방법은 명시적으로 규정하지 않고 있기 때문에 브라우저 기반 클라이언트에서는 헤더 또는 토큰을 직접 전달하는 데 제약이 존재
- 따라서 STOMP over WebSocket 환경에서는 CONNECT 프레임 헤더에 토큰을 포함시키고 서버 측에서 이를 읽어 인증 후 `Principal`을 설정하는 방식이 권장

<br>

## 구현 방식 및 코드 예제

#### 1. 클라이언트에서 인증 헤더 포함

- STOMP 클라이언트에서 `CONNECT` 요청 시 헤더에 토큰을 포함함

```js
const header = {
    Authorization: "Bearer <your-jwt-token>"
};

stompClient.connect(headers, frame => {
    // connected
});
```

<br>

#### 2. 서버 측 인증 처리 - `ChannelInterceptor` 사용

- `@EnableWebSocketMessageBroker` 설정 클래스에서 `configureClientInboundChannel(..)` 메서드를 통해 채널 인터셉터를 등록

```java
@Configuration
@EnableWebSocketMessageBroker
public class WebSocketConfig implements WebSocketMessageBrokerConfigurer {
    @Override
    public void configureClientInboundChannel(ChannelRegistration registration) {
        registration.interceptors(new ChannelInterceptor() {
            @Override
            public Message<?> preSend(Message<?> message, MessageChannel channel) {
                StompHeaderAccessor accessor = MessageHeaderAccessor
                                              .getAccessor(message, StompHeaderAccessor.class);
                if (StompCommand.CONNECT.equals(accessor.getCommand())) {
                    String token = accessor.getFirstNativeHeader("Authorization");
                    // 토큰 검증 로직 수행
                    Authentication user = authenticateToken(token);
                    accessor.setUser(user);
                }
                return message;
            }
        });
    }
}
```

<br>