---
layout: post
title: Interception
date: 2025-10-24 09:00:00 +09:00
categories: [Spring, Servlet Stack, Web MVC, WebSockets, STOMP]
tags: [spring]
image:
    path: /assets/img/spring/Spring.png
---

## 개요

- 이벤트 방식만으로는 모든 메시지 흐름을 제어하기에 부족할 수 있음
- 이럴 때는 `ChannelInterceptor`를 활용하여 메시지 전송 전후에 추가적인 처리를 할 수 있음
- 즉, 클라이언트 ➡️ 서버로 들어오는 메시지, 서버 ➡️ 클라이언트로 나가는 메시지 모두에 대해 들어오거나 나가기 전에/후에 처리할 수 있는 훅을 제공

<br>

## 주요 개념 및 구성


| 항목 | 설명 |
|-|-|
| ChannelRegistration | `WebSocketMessageBrokerConfigurer` 구현 시 `configureClientInboundChannel()` 또는 `configureClientOutboundChannel()` 메서드에서 사용 |
| ChannelInterceptor | 메시지가 채널로 보내지기 전 또는 후 등에 개입할 수 있는 인터페이스 |
| ExecutionChannelInterceptor | `ChannelInterceptor`의 하위 인터페이스로, 메시지 핸들러가 실행되는 쓰레드에서 호출되는 콜백을 제공. 메시지를 보내는 채널뿐 아니라 처리하는 쓰레드 환경까지 제어 가능 |
| 헤더 접근 도구 | `StompHeaderAccessor.wrap(message)` 또는 `SimpMessageHeaderAccessor.wrap(message)` 등을 통해 STOMP 커맨드, 세션 ID, 사용자 principal 등 메시지 헤더 정보를 추출할 수 있음 |

<br>

## 활용 가능한 흐름

#### 1. `@Configuration` 및 `@EnableWebSocketMessageBroker` 설정 클래스 생성

#### 2. `WebSocketMessageBrokerConfigurer` 구현

```java
@Override
public void configureClientInboundChannel(ChannelRegistration registration) {
    registration.interceptors(new MyChannelInterceptor());
}
```

<br>

#### 3. `MyChannelInterceptor` 클래스 구현

```java
public class MyChannelInterceptor implements ChannelInterceptor {
    @Override
    public Message<?> preSend(Message<?> message, MessageChannel channel) {
        StompHeaderAccessor accessor = StompHeaderAccessor.wrap(message);
        StompCommand command = accessor.getCommand();

        return message;
    }
}
```

<br>

#### 4. 인터셉터 내부에서 흔히 하는 작업

- `CONNECT` 또는 `DISCONNECT` 프레임 감지 ➡️ 인증/로그아웃 처리
- `SUBSCRIBE` 요청 시 사용자 권한 확인 ➡️ 허가/거부
- `SEND` 메시지에 대해 특정 헤더 검사 또는 메시지 변형
- 메시지 postSend / afterSendCompletion 등을 통한 리소스 클린업

<br>

## 유의사항 및 팁

- `DISCONNECT` 메시지는 클라이언트가 명시적으로 보낸 경우이거나 