---
layout: post
title: Interception
date: 2025-10-24 09:00:00 +09:00
categories: [Spring, Servlet Stack, Web MVC, WebSockets, STOMP]
tags: [spring]
image:
    path: /assets/img/spring/Spring.png
---

## 개요

- 이벤트 방식만으로는 모든 메시지 흐름을 제어하기에 부족할 수 있음
- 이럴 때는 `ChannelInterceptor`를 활용하여 메시지 전송 전후에 추가적인 처리를 할 수 있음
- 즉, 클라이언트 ➡️ 서버로 들어오는 메시지, 서버 ➡️ 클라이언트로 나가는 메시지 모두에 대해 들어오거나 나가기 전에/후에 처리할 수 있는 훅을 제공

<br>

## 주요 개념 및 구성


| 항목 | 설명 |
|-|-|
| ChannelRegistration | `WebSocketMessageBrokerConfigurer` 구현 시 `configureClientInboundChannel()` 또는 `configureClientOutboundChannel()` 메서드에서 사용 |
| ChannelInterceptor | 메시지가 채널로 보내지기 전 또는 후 등에 개입할 수 있는 인터페이스 |
| ExecutionChannelInterceptor | `ChannelInterceptor`의 하위 인터페이스로, 메시지 핸들러가 실행되는 쓰레드에서 호출되는 콜백을 제공. 메시지를 보내는 채널뿐 아니라 처리하는 쓰레드 환경까지 제어 가능 |
| 헤더 접근 도구 | `StompHeaderAccessor.wrap(message)` 또는 `SimpMessageHeaderAccessor.wrap(message)` 등을 통해 STOMP 커맨드, 세션 ID, 사용자 principal 등 메시지 헤더 정보를 추출할 수 있음 |

<br>

## 활용 가능한 흐름

#### 1. `@Configuration` 및 `@EnableWebSocketMessageBroker` 설정 클래스 생성

#### 2. `WebSocketMessageBrokerConfigurer` 구현

```java
@Override
public void configureClientInboundChannel(ChannelRegistration registration) {
    registration.interceptors(new MyChannelInterceptor());
}
```

<br>

#### 3. `MyChannelInterceptor` 클래스 구현

```java
public class MyChannelInterceptor implements ChannelInterceptor {
    @Override
    public Message<?> preSend(Message<?> message, MessageChannel channel) {
        StompHeaderAccessor accessor = StompHeaderAccessor.wrap(message);
        StompCommand command = accessor.getCommand();

        return message;
    }
}
```

<br>

#### 4. 인터셉터 내부에서 흔히 하는 작업

- `CONNECT` 또는 `DISCONNECT` 프레임 감지 ➡️ 인증/로그아웃 처리
- `SUBSCRIBE` 요청 시 사용자 권한 확인 ➡️ 허가/거부
- `SEND` 메시지에 대해 특정 헤더 검사 또는 메시지 변형
- 메시지 postSend / afterSendCompletion 등을 통한 리소스 클린업

<br>

## 유의사항 및 팁

- `DISCONNECT` 메시지는 클라이언트가 명시적으로 보낸 경우이거나, 웹소켓 세션이 닫히면서 자동 생성되는 경우가 있음
  - 이 때문에 동일 세션에 대해 인터셉터가ㅏ 여러 번 감지될 수 있음
- `ChannelInterceptor`는 메시지 패널 단에서 작동하므로, 메시지 처리 흐름 전체 중에서 어느 지점에서 개입할지 설계해야 함
- `ExecutionChannelInterceptor`를 사용할 경우, 메시지 핸들러의 실행 환경까지 고려할 수 있으나 그만큼 복잡도가 올라가므로 실제 필요 여부를 판단하는 것이 좋음
- 헤더 접근 시 `StompHeaderAccessor` 또는 `SimpMessageHeaderAccessor`를 잘 활용하면, STOMP 커맨드 유형이나 사용자의 세션 ID/사용지명 등을 꺼낼 수 있어 인증,추적 목적으로 매우 유용
- 인터셉터에서 메시지를 변형하거나 거부할 경우 `return null` 또는 예외 던지기 등의 방식이 있을 수 있으므로, 처리 흐름과 예외 처리를 명확히 설계해야 함