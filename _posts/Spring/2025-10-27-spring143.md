---
layout: post
title: STOMP Client
date: 2025-10-27 09:00:00 +09:00
categories: [Spring, Servlet Stack, Web MVC, WebSockets, STOMP]
tags: [spring]
image:
    path: /assets/img/spring/Spring.png
---

## 개요

- Spring은 WebSocket 위에 STOMP 프로토콜을 사용하는 클라이언트 기능을 제공
- 즉, 서버 측에서 STOMP를 사용하고 있다면, 클라이언트도 Java에서 WebSocketStompClient 등을 만들어 STOMP 세션을 연결하고 메시지를 주고 받을 수 있음
- 또한 STOMP over TCP 방식도 지원

<br>

## 주요 구성요소 및 흐름

#### 1. 클라이언트 생성 및 설정

- WebSocket 클라이언트를 먼저 생성해야 함

```java
WebSocketClient webSocketClient = new StandardWebSocketClient();
WebSocketStompClient stompClient = new WebSocketStompClient(webSocketClient);
stompClient.setMessageConverter(new StringMessageConverter());
stompClient.setTaskScheduler(taskScheduler); // heartbeats 용
```

- 위 예제에서 `StandardWebSocketClient` 대신 SockJsClient를 사용할 수 있으며, SockJS는 WebSocket을 기본으로 하되 HTTP-fallback등을 지원

<br>

#### 2. 서버와 연결

- URL 예시: `"ws://127.0.0.1:8080/endpoint"`
- STOMP 세션 핸들러를 구현한 클래스를 준비하고 연결을 시도

```java
String url = "ws://127.0.0.1:8080/endpoint";
StompSessionHeader = new MyStompSessionHandler();
stompClient.connect(url, sessionHandler);
```

- 세션이 연결되고 나면, `afterConnected()` 같은 콜백이 호출

```java
public class MyStompSessionHandler extends StompSessionHandlerAdapter {
    @Override
    public void afterConnected(StompSession session, StompHeaders connectedHeaders) {
        // 연결 완료 시 실행할 로직
    }
}
```

<br>

#### 3. 메시지 송신 및 구독

- 연결된 세션을 사용해 메시지를 보낼 수 있음

```java
session.send("/topic/something", "payload");
```

- 이때 `payload`는 `MessageConverter` 설정에 따라 직렬화됨

<br>

- 구독하려면 `session.subscribe()` 메서드를 사용하고, 핸들러를 지정해야 함

```java
session.subscribe("/topic/something", new StompFrameHandler() {
    @Override
    public Type getPayloadType(StompHeaders headers) {
        return String.class;
    }

    @Override
    public void handleFrame(StompHeaders headers, Object payload) {
        // 받은 메시지 처리
    }
});
```

<br>

#### 4. 하트비트 및 수신/송신 유휴 상태

- 하트비트를 활성화하려면 `WebSocketStompClient`에 `TaskScheduler`를 설정하고, write inactivity 및 read inactivity 시간을 지정
- 참고: 외부 브로커를 사용하는 경우 메시지는 보내졌지만 브로커로 포워딩되지 않았다면 inactivity로 인식되어 하트비트가 보내지지 않을 수 있으므로 주의해야 함
- 성능 테스트 용도 등으로 하트비트를 끄는 것이 더 나을 수 있음

<br>

#### 5. Receipts 기능

- STOMP 프로토콜의 `receipt` 헤더를 사용하면, 클라이언트가 전송 또는 구독 요청을 하고 서버가 처리 완료되면 `RECEIPT` 프레임으로 웅답을 보내주는 구조가 가능
- 클라이언트 측에서는 `StompSession.setAutoReceipt(boolean)` 메서드를 통해 자동으로 `receipt` 헤더를 추가하도록 설정할 수 있음
- 또는 수동으로 헤더에 `receipt`를 추가해서 요청하고, `Receiptable` 객체를 통해 성공/실패 콜백을 등록할 수 있음

<br>

## 실무 팁 & 유의사항

- 클라이언트 설정 시 꼭 MessageConverter를 지정해야 직렬화/역직렬화가 올바르게 됨
- 하트비트 설정을 통해 연결이 유휴인 상태에서도 살아있음을 유지하거나 연결 상태를 빠르게 감지할 수 있음
- 외부 브로커를 사용할 경우 클라이언트 유휴 감지 및 하트비트 전략이 더 중요함
- `receipt` 기능은 메시지 송신/구독의 안정성을 높이고 싶을 때 유용
- 다수의 클라이언트를 한 머신에서 시뮬레이션할 경우, 하트비트를 끄는 것이 리소스 측명에서 유리할 수 있음
- 구독/구독취소/메시지 송수신 패턴을 잘 설계하여, 클라이언트-세션 상태 추적이나 오류 대응을 고려