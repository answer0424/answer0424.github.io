---
layout: post
title: Controller
date: 2025-10-28 09:00:00 +09:00
categories: [Spring, Reactive Stack, WebFlux, Annotated Controllers]
tags: [spring]
image:
    path: /assets/img/spring/Spring.png
---

## 개요
- WebFlux에서는 어노테이션 기반 컨트롤러 모델을 제공하며, 기존 Spring MVC 방식과 유사하게 `@Controller`, `@RestController`, `@RequestMapping` 계열 어노테이션을 활용해 요청을 매핑할 수 있음
- 어노테이션 기반 컨트롤러 모델은 별도의 인터페이스나 베이스 클래스 상속 없이 메서드만으로 리퀘스트/리스폰스 처리를 구현할 수 있음

```java
@RestController
public class HelloController {
    @GetMapping("/hello")
    public String handle() {
        return "Hello, WebFlux!";
    }
}

```

- 위 예제는 `@RestController`와 `@GetMapping`을 사용한 기본 구조로, 동기 방식으로 문자열을 반환하는 간단한 엔드 포인트
- 리액티브 방식으로 바꾸게 될 경우:

```java
@RestController
public class HelloController {
    @GetMapping("/hello")
    public Mono<String> handleReactive() {
        return Mono.just("Hello, WebFlux Reactive!");
    }
}
```

<br>

## 메서드 인자 & 반환값

- 컨트롤러 메서드는 다양한 인자를 받을 수 있음(`@PathVariable`, `@RequestParam`, `@RequestBody`, `ServerWebExchange` 등) - 리액티브 타입도 지원됨
- 반환값으로는 일반 객체, `Mono<T>`, `Flux<T>`, `ResponseEntity<T>` 등이 가능하며, HTTP 상태/헤더 제어도 가능

```java
@GetMapping("/users/{id}")
public Mono<ResponseEntity<User>> getUser(@PathVariable String id) {
    return userService.findById(id)
        .map(user -> ResponseEntity.ok(user))
        .defaultIfEmpty(ResponseEntity.notFound().build());
}
```

<br>

## 유의사항 및 팁

- WebFlux 컨트롤러가 리액티브 모델을 제대로 활용하려면, 블로킹 호출을 피해야 하며, 리액터나 리액트 기반 타입을 활용하는 것이 권장
- `@Controller` 대신 `@RestController`를 사용하면 메서드마다 `@ResponseBody`를 자동으로 적용하게 되어 코드를 단순화할 수 있음
- 