---
layout: post
title: Method Arguments
date: 2025-11-05 09:00:00 +09:00
categories: [Spring, Reactive Stack, WebFlux, Annotated Controllers]
tags: [spring]
image:
    path: /assets/img/spring/Spring.png
---

## 개요

- 리액티브 웹 스택인 Spring WebFlux에서 어노테이션 기반 컨트롤러 메서드의 인자로 어떤 타입이 지원되는지 정리
- 특히 블로팅 I/O가 필요한 인자에 대해 Reactor 또는 RxJava 타입을 지원한다는 점이 특징
- 또한 별도 어노테이션이 없는 인자는 기본적으로 간단한 타입이면 `@RequestParam`으로 아니면 `@ModelAttribute`로 처리됨

<br>

## 지원되는 주요 인자 유형

| 인자 타입 | 설명 |
|-|-|
| `ServerWebExchange` | 전체 리퀘스트/리스폰스/세션/속성 등에 접근 가능한 교환 객체 |
| `ServerHttpRequest`, `ServerHttpResponse` | HTTP 요청 또는 응답 객체 |
| `WebSession` | 리액티브 세션 객체 |
| `java.security.Principal` | 인증된 사용자 정보 |
| `HttpMethod` | 요청의 HTTP 메서드 |
| `Locale`, `TimeZone`, `ZoneId` | 요청에 따른 지역 또는 시간대 정보 |
| `@PathVariable` | 경로 변수 바인딩 |
| `@MatrixVariable` | 경로 세그먼트 내부의 행렬 변수 지원 |
| `@RequestParam` | 쿼리 파라미터 값을 바인딩. 타입 변환 지원 |
| `@RequestHeader` | 요청 헤더 값을 바인딩 |
| `@CookieValue` | 쿠키 값을 바인딩 |
| `@RequestBody` | 요청 본문을 바인딩. 리액티브 타입(`Mono<T>`, `Flux<T>`) 지원 |
| `HttpEntity<B>` | 요청 헤더 +  바디 접근용 래퍼 | 
| `@RequestPart` | `multipart/form-data` 요청의 특정 파트 바인딩 |
| `Map`, `Model` | 모델 데이터 접근. HTML 렌더링을 위한 컨텍스트 |
| `@ModelAttribute` | 폼 데이터 바인딩 및 검증 지원 |
| `Errors`, `BindingResult` | `@ModelAttribute` 바인딩/검증 에러 정보를 바로 뒤에 선언하여 접근 가능 |
| `@SessionAttribute` | 세션 속성 바인딩 |
| `@RequestAttribute` | 요청 속성 바인딩 |

<br>

## 예제 코드

```java
@RestController
@RequestMapping("/users")
public class UserController {

    @GetMapping("/{id}")
    public Mono<User> getUser(
        @PathVariable("id") String id,
        @RequestHeader("X-Request-ID") String requestId,
        Principal principal,
        ServerWebExchange exchange) {

        System.out.println("Request-ID: " + requestId);
        System.out.println("Authenticated user: " + principal.getName());
        return userService.findById(id);
    }

    @PostMapping
    public Mono<ResponseEntity<Void>> createUser(
        @RequestBody Mono<CreateUserRequest> requestMono) {

        return requestMono
            .flatMap(req -> userService.create(req))
            .map(userId -> ResponseEntity.created(
                        URI.create("/users/" + userId)).build());
    }
}
```

- `@PathVariable`, `@RequestHeader`, `Principal`, `ServerWebExchange` 등 다양한 인자 사용 예시
- POST 메서드에서는 `@RequestBody Mono<CreateUserRequest>` 형태로 리액티브 타입이 사용되었음

<br>

## 유의사항 및 팁

- 요청 본문을 읽는 인자(`@RequestBody`, `@RequestPart`, `HttpEntity`)는 블로킹 작업을 피해야 하므로, 리액티브 타입 사용이 권장됨
- `@ModelAttribute` 방식의 객체 바인딩을 사용할 때는, 비간단 타입이거나 별도 어노테이션이 없는 인자는 자동으로 `@ModelAttribute`로 처리될 수 있으나, 유지보수성 및 명시성을 가능하면 어노테이션을 붙이는 것이 좋음
- 여러 인자를 사용하는 경우, `Errors`나 `BindingResult` 인자는 바로 해당 `@ModelAttribute` 인자 뒤에 선언해야 함
    - 그렇지 않을 경우 올바르게 바인딩된 오류 정보를 받을 수 없음
- 