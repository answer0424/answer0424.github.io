---
layout: post
title: ModelAttribute
date: 2025-11-17 09:00:00 +09:00
categories: [Spring, Reactive Stack, WebFlux, Annotated Controllers, Handler Methods]
tags: [spring]
image:
    path: /assets/img/spring/Spring.png
---

## 개요

- `@ModelAttribute`를 메서드 인자에 붙이면, 요청 파라미터나 URI 변수 또는 요청 헤더 등의 값을 해당 타입 객체에 바인딩하고 이 객체를 모델의 속성으로 노출시켜 줌
- 즉, 단일 값이 아닌 복합 타입 객체를 자동으로 생성하고 초기화해서 컨트롤러 메서드 인자로 받을 수 있음
- 컨트롤러 메서드 인자로 받을 수 있음
- `@ModelAttibute` 어노테이션을 생략하더라도 단순 값이 아닌 인자 타입이며 다른 Argument Resolver에 의해 처리되지 않는 경우에는 자동으로 `@ModelAttribute`로 간주됨

<br>

## 동작 방식 및 특징

#### 인스턴스 생성 및 특징

- 모델 속성 이름은 기본적으로 인자 타입의 클래스 명으로 유추됨
  - 예컨대 `Pet` 타입이라면 `pet`이 속성명임
- 속성값 객체는 다음 경로 중 하나로 생성
  1. 이미 모델에 존재하는 속성 ➡️ 재사용
  2. 클래스-레벨 `@SessionAttributes`에 등록된 속성이면 HTTP 세션에서 조회
  3. `Converter<String, T>`를 통해 문자열 요청값을 객체로 변환
  4. 기본 생성자를 통해 인스턴스 생성
  5. 생성자 매개변수 방식으로 생성될 수 있음
- 인스턴스화 후에는 `WebDataBinder`를 통해 요청 파라미터 이름과 인스턴스의 필드/속성이 매칭되어 자동으로 바인딩 됨
  - 예컨대 `name=Fluffy=3` 같은 폼 파라미터가 `Pet` 객체의 `name`, `age` 필드로 설정됨

<br>

#### `BindingResult` 및 검증

- 바인딩 과정에서 오류가 발생할 수 있으며(`BindException`), 컨트롤러 메서드 인자로 `BindingResult`를 바로 뒤에 선언함으로써 오류 정보를 직접 처리할 수 있음
- `@Valid` 또는 `Validated` 어노테이션을 `@ModelAttribute` 인자 앞에 붙이면, 바인딩 후 자동으로 검증이 수행되고 오류 시 예외가 던져지거나 `BindingResult`로 접근 가능

<br>

#### `binding=false` 옵션

- `@ModelAttribute(binding=false)`로 지정하면 데이터 바인딩을 하지 않고 모델 속성만 조회하거나 설정하는 용도로 사용됨

<br>

## 예제

```java
@PostMapping("/owners/{ownerId}/pets/{petId}/edit")
public String processSubmit(
    @ModelAttribute Pet pet,      // 요청 파라미터 → Pet 객체 바인딩
    BindingResult result) {       // 바로 뒤에 BindingResult 선언
    if (result.hasErrors()) {
        return "petForm";
    }
    petService.save(pet);
    return "redirect:/owners/" + pet.getOwnerId();
}
```


```java
@PutMapping("/accounts/{accountId}")
public String save(
    @ModelAttribute("account") Account account) {  // 속성명 명시적으로 지정
    // account 객체: path variable ‘account’ 혹은 요청 파라미터로부터 변환됨
    accountService.update(account);
    return "accountView";
}
```

<br>

## 유의사항 및 팁

- 모델 객체 설계 시 주의할 점:
  - 프론트엔드에서 조작 가능한 폼 필드와 직접적으로 바인되는 DTO를 사용하는 것이 좋으며, JPA 엔티티를 그대로 바인딩 모델로 사용하는 것은 보안 위험이 있음
- `@ModelAttribute` 인자를 선언할 경우 반드시 바인딩 가능한 생성자 또는 기본 생성자 + setter 메서드가 존재해야 하며, 생성자 바인딩 또는 프로퍼티 바인딩 중 방식 선택이 필요할 수 있음
- `@SessionAttributes` 와 함께 사용될 때는 세션 스코프 모델 관리, 세션 값 초기화, 세션 종료 시 속세제거 설정 등을 염두해 두어야 함
- `@ModelAttribute`가 생략된 경우라도 단수 타입이 아닌 인자라면 자동으로 모델 속성으로 처리되므로 코드 유지보수를 위해 명시적으로 어노테이션을 사용하는 것이 좋음