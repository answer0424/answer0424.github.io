---
layout: post
title: RequestBody
date: 2025-11-17 09:00:00 +09:00
categories: [Spring, Reactive Stack, WebFlux, Annotated Controllers, Handler Methods]
tags: [spring]
image:
    path: /assets/img/spring/Spring.png
---

## 개요

- `@RequestBody` 어노테이션은 클라이언트가 전송한 HTTP 요청의 본문을 읽고 `HttpMessageConverter`를 통해 지정된 자바 객체로 역직렬화 해주는 기능
- 사용 예시:

```java
@PostMapping("/pets")
public void handle(@RequestBody Account account) {
    
}
```

- 주의사항으로, 폼 데이터를 처리할 때 `@RequestBody`를 사용하는 것은 권장되지 않음
- 요청 파라미터(`application/x-www-form-urlencoded`) 방식에서는 `@RequestParam`또느 `ModelAttribute` 방식이 더 안정적임

## 주요 기능 및 사용법

- `@RequestBody` 인자를 `@Valid` 또는 `@Validated`와 같이 사용하면, Bean Validation이 자동으로 적용되며 유효성 검사 실패 시 `MethodArgumentNotValidException`이 발생하고 기본적으로 HTTP 400 응답이 반환됨
- 예제:

```java
@PostMapping("/accounts")
public void handle(@Valid @RequestBody Account account, Errors errors) {
    if (errors.hasErrors()) {
        // 에러 처리
    }
    // 정상 처리
}
``` :contentReference[oaicite:6]{index=6}  
```

- `@RequestBody` 인자는 한 요청 내에서 하나만 선언하는 것이 일반적
- 반환형이 아니라 메서드 입력 인자용

<br>

## 유의사항 및 팁

- 요청 본문이 없음에도 `@RequestBody`가 필수 설정일 경우, 스프링은 예외를 던질 수 있음 ➡️ 인자를 선택적으로 받고 싶다면 `required=false` 또는 null 허용 타입 사용 고려해야 해야 함
- 요청의 `Content-Type` 헤더가 지정된 메시지 컨버터에서 지원하는 타입이어야 함
  - 예컨대 `application/x-www-form-urlencoded` 데이터에 `@RequestBody`를 사용하면 예상대로 동작하지 않을 수 있음
- `@RequestBody`와 `@ModelAttribute`는 서로 다른 목적을 갖음
  - `@RequestBody`: 본문 전체를 객체로 역직렬화
  - `@ModelAttribute`: 요청 파라미터 등을 객체 필드에 바인딩
- DTO 객체 설계 시, 요청에서 오는 JSON 구조와 DTO의 필드 구조가 맞게 설계되어야 역직렬화 오류를 줄일 수 있음
- 스프링 MVC 외에 리액티브 스택에서도 `@RequestBody` 유사 기능이 존재하며, 리액티브 타입을 인자로 받을 수 있음