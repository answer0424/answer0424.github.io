---
layout: post
title: Jackson JSON
date: 2025-11-18 09:00:00 +09:00
categories: [Spring, Reactive Stack, WebFlux, Annotated Controllers, Handler Methods]
tags: [spring]
image:
    path: /assets/img/spring/Spring.png
---

## 목적

- 객체 전체의 필드를 항상 직렬화하는 것이 아니라, 상황에 따라 필드의 일부만 직렬화할 수 있도록 함
  - 즉, 같은 객체라도 어떤 API 호출에서는 특정 필드만 보여주고 다른 호출에서는 더 많은 필드를 보여주는 형태로 제어할 수 있음
- 이는 API 응답에서 노출하고 싶지 않은 필드를 숨기거나, 요약/상세 모드로 나누어 응답을 제공할 때 유용

<hr>

## 사용방법

#### @JsonView 어노테이션 이용

- 컨트롤러 메서드에 `@JsonView(ViewClass.class)` 을 붙이면, 반환 객체에 대해 Jsackson이 해당 View를 활성화하여 직렬화 시 필드를 필터링 함

```java
@RestController
public class UserController {
    @GetMapping("/user")
    @JsonView(User.WithoutPasswordView.class)
    public User getUser() {
        return new User("eric", "7!jd#h23");
    }
}

public class User {
    public interface WithoutPasswordView {};
    public interface WithPasswordView extends WithoutPasswordView {};

    private String username;
    private String password;

    @JsonView(WithoutPasswordView.class)
    public String getUsername() { return username; }

    @JsonView(WithPasswordView.class)
    public String getPassword() { return password; }
}
```

- 위 예시에서 `/user` 호출 시 `WithoutPasswordView가 적용되어 `username`은 나온지만 `password`는 나오지 않음
- `@JsonView` 어노테이션에는 배열 형식도 지정할 수 있으나, 컨트롤러 메서드에는 하나만 지정가능함
  - 여러 개를 지정해야 한다면 합성 인터페이스를 만들어 사용해야 함

<br>

#### MappingJacksonValue를 이용한 프로그래매틱 설정

- 어노테이션 대신 코드 내부에서 직렬화 뷰를 설정하고 싶을 때 사용
  

```java
@GetMapping("/user")
public MappingJacksonValue getUser() {
    User user = new User("eric", "7!jd#h23");
    MappingJacksonValue value = new MappingJacksonValue(user);
    value.setSerializationView(User.WithoutPasswordView.class);
    return value;
}
```

- 이 경우, 반환 객체가 `MappingJacksonValue`이므로 message converter가 이를 인식해 해당 View를 적용

<br>

#### 뷰 리졸버 방식과의 연계

- `@Controller`가 뷰 리졸버를 사용하는 경우 모델에 `JsonView.class.getName()` 키로 뷰 클래스를 추가하는 방식으로도 지원됨

```java
@Controller
public class UserController {
    @GetMapping("/user")
    public String getUser(Model model) {
        model.addAttribute("user", new User("eric", "7!jd#h23"));
        model.addAttribute(JsonView.class.getName(), User.WithoutPasswordView.class);
        return "userView"; // 뷰 이름
    }
}
```

<hr>

## 주요 유의사항 및 추가 정보

- 기본적으로, `@JsonView`를 적용하면 뷰에 지정되지 않은 필드는 직렬화에서 제외됨
  - 이는 Jackson의 `MapperFeature.DEFAULT_VIEW_INCLUSION` 설정이 기본적으로 `false`로 설정되어 있기 때문
- `@JsonView`는 직렬화 레이어만 제어하면, 예컨대 DB에서 객체를 조회할 때 어떤 필드를 조회할지까지는 제어하지 않음
- 중첩 객체나 컬렉션 객체가 있을 경우, 해당 하위 객체의 필드에 대해서도 `@JsonView` 어노테이션을 일관되게 지정해야 원하는 형태로 직렬화됨
  - 그렇지 않으면 예상치 못한 필드가 포함될 수 있음
- Spring Framework는 Jackson 외에도 XML 직렬화와의 연계 기능을 제공하며 JSON View 기능을 XML 직렬화에도 동일하게 적용할 수 있음

<hr>

## 사용 시기

- 동일한 객체 타입을 여러 API에서 사용하되, 노출해야 할 필드가 경우마다 다를 때 유용
  - 예컨대 관리자용 API는 모든 필드를 보여주고 일반 사용자용 API는 일부 필드만 보여주는 경우
- 동일한 객체 타입이지만 요약 API vs 상세 API 등으로 나누어 응답 형태를 다르게 하고 싶을 때
- 컨트롤러 메서드 내부에서 동적으로 어떤 View를 적용할지 결정해야 할 때 `MappingJacksonValue` 방식이 적합