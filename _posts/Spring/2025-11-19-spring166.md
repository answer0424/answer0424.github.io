---
layout: post
title: Validation
date: 2025-11-19 09:00:00 +09:00
categories: [Spring, Reactive Stack, WebFlux, Annotated Controllers]
tags: [spring]
image:
    path: /assets/img/spring/Spring.png
---

## 개요

- Spring MVC는 `@RequestMapping` 방식의 컨트롤러 메서드에 대해 내장 검증 기능을 제공
- 특히 jakarta Bean Validation 방식과의 통합을 다룸
- 검증은 크게 두 수준에서 적용될 수 있음
  - 메서드 파라미터 단위 또는 요청 바디 단위 객체에 대한 검증
  - 메서드 전체에 대한 검증

<hr>

## 검증 적용 방식

#### 1. 파라미터 단위 검증

- `@ModelAttribute`, `@RequestParam`, `@RequestPart` 등의 메서드 파라미터로 바인딩된 커맨드 객체에 대해 `@jakarta.validation.Valid` 또는 `Spring`의 `@Validated` 어노테이션을 붙여 검증할 수 있음
- 다만 컨테이너 타입이거나 검증 후 바로 `Errors` 또는 `BindingResult` 객체가 메서드 시그니처에 이어서 오지 않으면 이 방식은 적용되지 않을 수 있음
- 검증 실패 시 발생하는 예외는 `MethodArgumentNotValidException`

<br>

#### 2. 메서드 레벨 검증

- 메서드의 파라미터  자체 또는 반환값에 `@Min`, `@NotBlank` 등의 제약 어노테이션이 직접 붙어 있는 경우, 또는 `@Validated`가 클래스나 메서드 수준에 붙어 있는 경우 메서드 레벨 검증이 적용됨
- 이 경우 검증 실패 시 `HandlerMethodValidationException` 예외가 발생
- 중요한 차이점: 파라미터 객체를 검증하는 파라미터 단위 검증과 달리 메서드 검증은 여러 파라미터 + 반환값까지 포괄할 수 있음

<hr>

## 설정 및 커스터마이징

- 글로벌하게 `Validator`를 설정하고 싶다면 WebMvcConfigurer 구현체의 `getValidator()` 등을 통해 설정할 수 있고, 컨트롤러나 `@ControllerAdvice` 클래스 내부에 `@InitBinder`메서드로 로컬 `Validator`를 적용할 수도 있음
- 검증 실패 시 응답을 어떻게 구성할지 문서에서는 `MessageSource` 및 리소스 번들을 활용해 커스터마이징할 수 있다고 안내하고 있음
- 예외 처리 방식도 중요하며, `MethodArgumentNotValidException`과 `HandlerMethodValidationException`를 `@ExceptionHandler` 또는 `ResponseEntityExceptionHandler` 등을 통해 처리할 수 있음

<hr>

## 개발 시 유의사항 및 팁

- 어떤 검증 방식이 적용되는지는 메서드 시그니처에 따라 달라질 수 있으므로, 파라미터 객체 + Errors/BindingResult 조합 혹은 제약 어노테이션 직접 등의 패턴을 잘 이해해야 함
- 메서드 검증을 활성화할 때는 `@Validated` 또는 관련 설정이 필요하며, 클래스 수준에 `@Validated`만 붙여도 AOP 기반으로 메서드 검증이 적용될 수 있음
- 검증 실패 시 나타나는 예외 종류가 두 가지라서 예외 처리 핸들링 코드를 둘 다 대응하도록 구현하면 좋음
- 반환값 검증 등 좀 더 고급 기능을 사용할 경우 메서드 검즈이 활성화되어 있는지 AOP 프록시 방식이 제대로 적용되어 있는지 등 설정을 확인하는 것이 중요