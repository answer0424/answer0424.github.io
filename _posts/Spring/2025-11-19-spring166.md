---
layout: post
title: Validation
date: 2025-11-19 09:00:00 +09:00
categories: [Spring, Reactive Stack, WebFlux, Annotated Controllers]
tags: [spring]
image:
    path: /assets/img/spring/Spring.png
---

## 개요

- Spring MVC는 `@RequestMapping` 방식의 컨트롤러 메서드에 대해 내장 검증 기능을 제공
- 특히 jakarta Bean Validation 방식과의 통합을 다룸
- 검증은 크게 두 수준에서 적용될 수 있음
  - 메서드 파라미터 단위 또는 요청 바디 단위 객체에 대한 검증
  - 메서드 전체에 대한 검증

<hr>

## 검증 적용 방식

#### 1. 파라미터 단위 검증

- `@ModelAttribute`, `@RequestParam`, `@RequestPart` 등의 메서드 파라미터로 바인딩된 커맨드 객체에 대해 `@jakarta.validation.Valid` 또는 `Spring`의 `@Validated` 어노테이션을 붙여 검증할 수 있음
- 다만 컨테이너 타입이거나 검증 후 바로 `Errors` 또는 `BindingResult` 객체가 메서드 시그니처에 이어서 오지 않으면 이 방식은 적용되지 않을 수 있음
- 검증 실패 시 발생하는 예외는 `MethodArgumentNotValidException`

<br>

#### 2. 메서드 레벨 검증

- 메서드의 파라미터  자체 또는 반환값에 `@Min`, `@NotBlank` 등의 제약 어노테이션이 직접 붙어 있는 경우, 또는 `@Validated`가 클래스나 메서드 수준에 붙어 있는 경우 메서드 레벨 검증이 적용됨
- 이 경우 검증 실패 시 `HandlerMethodValidationException` 예외가 발생
- 중요한 차이점: 파라미터 객체를 검증하는 파라미터 단위 검증과 달리 메서드 검증은 여러 파라미터 + 반환값까지 포괄할 수 있음

<hr>

## 설정 및 커스터마이징

- 글로벌하게 `Validator`를 설정하고 싶다면 WebMvcConfigurer 구현체의 `getValidator()` 등을 통해 설정할 수 있고, 컨트롤러나 `@ControllerAdvice` 클래스 내부에 `@InitBinder`메서드로 로컬 `Validator`를 적용할 수도 있음
- 검증 실패 시 응답을 어떻게 구성할지 문서에서는 `MessageSource` 및 리소스 번들을 활용해 커스터마이징할 수 있다고 안내하고 있음
- 예외 처리 방식도 중요하며, `MethodArgumentNotValidException`과 `HandlerMethodValidationException`를 `@ExceptionHandler` 또는 `ResponseEntityExceptionHandler` 등을 통해 처리할 수 있음