---
layout: post
title: HTTP Caching
date: 2025-11-21 09:00:00 +09:00
categories: [Spring, Reactive Stack, WebFlux]
tags: [spring]
image:
    path: /assets/img/spring/Spring.png
---

## 개요

- HTTP 캐싱은 웹 어플리케이션의 성능을 크게 향상시킬 수 있는 기법
- 주요 헤더:
  - `Cache-Control`: 브라우저/프록시 캐시에 응답을 어떻게 저장·재사용할지 지시함
  - 조건부 요청 헤더들: `If-Modified-Since`, `If-None-Match` 등을 이용해 내용이 변경되지 않았다면 304 Not Modified 응답을 할 수 있음


<hr>

## 주요 기능 및 사용 방식

#### Cache-Control 지원

- `org.springframwork.http.CacheControl` 클래스를 사용해 캐싱 규칙을 표현할 수 있음


```java
CacheControl ccCacheOneHour = CacheControl.maxAge(1, TimeUnit.HOURS);
CacheControl ccNoStore     = CacheControl.noStore();
CacheControl ccCustom      = CacheControl
                                 .maxAge(10, TimeUnit.DAYS)
                                 .cachePublic()
                                 .noTransform();
```

- `WebContentGenerator` 또는 `WebContentInterceptor` 같은 클래스에서도 단순한 `cachePeriod` 방식으로 설정 가능
  - `-1`: Cache-Control 헤더 생략
  - `0`: `Cache-Control: no-store` (캐싱 금지)
  - `n>0` : `Cache-Control: max-age=n`

<br>

#### 컨트롤러에서의 적용

- 컨트롤러 메서드에서 `ResponseEntity`를 사용해 캐시 헤더와 ETag를 설정할 수 있음

```java
@GetMapping("/book/{id}")
public ResponseEntity<Book> showBook(@PathVariable Long id) {
    Book book = findBook(id);
    String version = book.getVersion();

    return ResponseEntity.ok()
        .cacheControl(CacheControl.maxAge(30, TimeUnit.DAYS))
        .eTag(version)
        .body(book);
}
```

- 위 코드에서는 `Cache-Control` 헤더와 `ETag` 헤더가 응답에 추가됨

- 또는 `WebRequest.checkNotModified(...)` 메서드를 사용해 조건부 요청을 수동으로 검사할 수 있음

```java

@RequestMapping("/myResource")
public String handle(WebRequest request, Model model) {
    long eTag = …; // 애플리케이션이 계산한 버전값
    if (request.checkNotModified(eTag)) {
        return null; // 이미 304 응답이 설정됨
    }
    model.addAttribute(...);
    return "myViewName";
}
``` :contentReference[oaicite:9]{index=9}  
```

<br>

#### 정적 리소스에서의 캐싱

- 정적 리소스를 제공할 때도 `Cache-Control`과 조건부 응답 헤더를 사용하는 것이 권장됨
- `ShallowEtagHeaderFilter` 같은 필터를 이용해 응답 내용 기반의 얕은 ETag를 자동 생성할 수 있음

<hr>

## 사용 이유

- 빈번히 요청되는 리소스에 대해 동일한 응답을 재사용 가능하다면 캐싱을 활용해 네트워크 트래픽과 서버 부하를 줄일 수 있음
- 클라이언트와 중복 요청을 줄이고, 응답 시간을 단축하고 싶을 때 유용
- 조건부 요청을 이용해 변경이 없으면 본문 없이 응답하는 구조로 효율성을 높일 수 있음 