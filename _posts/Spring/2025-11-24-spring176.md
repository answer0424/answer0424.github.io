---
layout: post
title: WebFlux Config
date: 2025-11-24 09:00:00 +09:00
categories: [Spring, Reactive Stack, View Technologies]
tags: [spring]
image:
    path: /assets/img/spring/Spring.png
---

## 개요

- WebFlux를 사용하면 어노테이션 기반 컨트롤러 또는 함수형 엔드포인트를 처리하기 위한 필수 컴포넌트들이 자동 등록됨
- 기본적으로 빈이 일일이 설정할 필요없이, `WebFluxConfigurer`를 구현해서 필요한 부분만 오버라이드해서 커스터마이징 가능
- 고급 설정이 필요하면 `@EnableWebFlux` 대신 `DelegationWebFluxConfiguration`을 상송하는 고급 모드 사용도 가능함

<hr>

## WebFlux 설정 활성화 (`@EnableWebFlux`)

- Java 설정에서 `@EnableWebFlux`를 붙여 WebFlux 환경을 활성화할 수 있음
- Spring boot를 쓴다면, `WebFluxConfigurer` 구현체만 두고 `@EnableWebFlux`는 생략하는 방식으로도 Boot 자동 설정을 유지할 수 있음

```java
@Configuration
@EnableWebFlux
public class WebConfig implements WebFluxConfigurer {
    // WebFluxConfigurer 메서드 오버라이드 가능
}
```

<hr>

## 변환(Converstion) / 포맷팅(Formatting)

- 기본적으로 숫자 타입, 날짜 타입 등에 대해 포매터가 등록되어 있음
- `addFormatters(FormatterRegistry registry)`를 통해 커스텀 변환기나 컨버터를 등록할 수 있음
- 날짜/시간 포맷을 ISO 포맷으로 강제하고 싶을 경우, `DateTimeFormatterRegistrar`를 사용


```java
@Configuration
public class WebConfig implements WebFluxConfigurer {
    @Override
    public void addFormatters(FormatterRegistry registry) {
        DateTimeFormatterRegistrar registrar = new DateTimeFormatterRegistrar();
        registrar.setUseIsoFormat(true);
        registrar.registerFormatters(registry);
    }
}
```

<hr>

## 검증(Validation)

- Bean Validation이 클래스 패스에 있으면, 기본으로 `LocalValidatorFactoryBean`이 글로벌 Validator로 등록됨
- `getValidator()` 메서드를 오버라이드해서 커스텀 Validator 빈을 지정할 수 있음
- 또한, `@InitBinder`를 사용하여 특정 컨트롤러에 로컬 Validator를 설정하는 것도 가능

<hr>

## 요청 컨텐츠 타입 결정

- WebFlux는 기본적으로 `Accept` 헤더를 보고 미디어 타입을 결정
- `configureContentTypeResolver(RequestedContentTypeResolverBuilder builder)`를 오버라이드해서 쿼리 파라미터 기반 콘텐츠 타입 결정 전략을 추가할 수 있음

```java
@Configuration
public class WebConfig implements WebFluxConfigurer {
    @Override
    public void configureContentTypeResolver(RequestedContentTypeResolverBuilder builder) {
        builder.parameterResolver("format"); // 예: ?format=json
    }
}
```

<hr>

## HTTP 메시지 코드(Message Codecs)

- `configureHttpMessageCodecs(ServerCodecConfigurer configurer)` 메서드를 통해 요청 및 응답 바디를 읽고 쓰는 리더/라이터를 설정 가능
- 예: `maxInMemorySize` 조절해서 메모리 버퍼 제한 설정

```java
@Configuration
public class WebConfug implements WebFluxConfigurer {
    @Override
    public void configureHttpMessageCodecs(ServerCodecConfigurer configurer) {
        configurer.defaultCodecs().maxInMemorySize(16 * 1024 * 1024); // 16MB
    }
}
```

<hr>

## View Resolver

- `configureViewResolvers(ViewResolverRegistry registry)`를 오버라이드해서 템플릿 기반 뷰, 컨텐츠 협상 뷰 등을 등록할 수 있음
  
```java
@Configuration
public class WebConfig implements WebFluxConfigurer {
    @Override
    public void configureViewResolvers(ViewResolverRegistry registry) {
        registry.freeMarker();
        registry.defaultViews(new HttpMessageWriterView(new Jackson2JsonEncoder()));
    }

    @Bean
    public FreeMarkerConfigurer freeMarkerConfigurer() {
        FreeMarkerConfigurer configurer = new FreeMarkerConfigurer();
        configurer.setTemplateLoaderPath("classpath:/templates");
        return configurer;
    }
}
```


<hr>

## 정적 리소스 처리

- `addResourceHandlers(ResourceHandlerRegistry registry)`로 정적 리소스를 서빙할 수 있음

```java
@Configuration
public class WebConfig implements WebFluxConfigurer {
    @Override
    public void addResourceHandlers(ResourceHandlerRegistry registry) {
        registry.addResourceHandler("/resources/**")
                .addResourceLocations("classpath:/static/", "/public/")
                .setCacheControl(CacheControl.maxAge(365, TimeUnit.DAYS));
    }
}
```

- 리소스 체닝도 지원: `VersionResourceResolver` 등을 사용해 버전된 리소스 URL을 설정할 수 있음
- `ResourceWebHandler` 빈을 통해 URL 재작성을 지원할 수 있음
  - 그러나 WebFlux에서는 MVC처럼 non-blocking 방식으로 뷰 템플릿 안에서 리소스 URL을 투명하게 재작성하는 방식은 제한적임

<hr>

##  경로 매핑(Path Matching)

- `configurePathMatching(PathMatchConfigurer configurer)`를 오버라이드하여 경로 매칭 방식 설정 가능
- 예시: `RestController` 클래스에 공통 경로 프리픽스 지정

```java
@Configuration
public class WebConfig implements WebFluxConfigurer {
    @Override
    public void configurePatgMatching(PathMatchConfigurer configurer) {
        configurer.addPathPrefix("/api", HandlerTypePredicate.forAnnotation(RestController.class));
    }
}
```

- WebFlux는 `RequestPath`를 사용하여 경로 세그먼트를 분석하고, 세미콜론 매트릭스 변수 처리가 기본적으로 제어됨
- 또한, MVC의 접미사 패턴 매칭은 WebFlux에서 지원되지 않는 것이 권고됨


<hr>

## API 버전 관리

- WebFlux에서도 `ApiVersionConfigurer`를 통해 API 버전 관리를 설정할 수 있음

```java
@Configuration
public class WebConfig implements WebFluxConfigurer {
    @Override
    public void configureApiVersioning(ApiVersionConfigurer configurer) {
        configurer.useRequestHeader("API-Version");
    }
}
```
- 지원 가능한 전략: 요청 헤더, 쿼리 파라미터, 경로 세그먼트, 미디어 타입 파라미터 등
- 기본 버전 파서: `SemanticVersionParser`이며, 필요 시 커스텀 파서 사용 가능
- 지원되지 않는 버전 요청은 `InvalidApiVersionException`으로 처리될 수 있고, 400 응답을 반환하게 설정 가능함
- `ApiVersionDeprecationHandler`를 설정해서 이전된 버전에 대한 정보를 클라이언트에게 제공할 수 있음

<hr>

## 블로킹 실행 설정

- WebFlux에서도 블로킹 코드를 실행해야 할 경우 `configureBlockingExecution(BlockingExecutionConfigurer configurer)`를 통해 블로킹 작업 전용 실행자를 지정할 수 있음

```java
@Configuration
public class WebConfig implements WebFluxConfigurer {
    @Override
    public void configureBlockingExecution(BlockingExecutionConfigurer configurer) {
        AsyncTaskExecutor executor = new YourCustomExecutor();
        configurer.setExecutor(executor);
    }
}
```

- 기본적으로 WebFlux는 반환 타입이 리액티브 타입이 아니면 블로킹 메서드로 간주함 커스텀 기준을 지정할 수도 있음

<hr>

## WebSocket 설정

- WebFlux Java 설정은 `WebSocketConfigurer` 빈을 기본으로 등록함
- WebSocket 서버 설정을 커스터마이즈하고 싶다면 `WebSocketService`를 오버라이드 가능

```java
@Configuration
public class WebConfig implements WebFluxConfigurer {
    @Override
    public WebSocketService getWebSocketService() {
        TomcatRequestUpgradeStrategy strategy = new TomcatRequestUpgradeStrategy();
        strategy.setMaxSessionIdleTimeout(0L);
        return new HandshakeWebSocketService(strategy);
    }
}
```

## 고급 구성 모드

- 기본 설정이 `@EnableWebFlux` + `WebFluxConfigurer` 조합이지만, 고급 설정이 필요하면 `DelegatingWebFluxConfiguration`을 상속하는 방법도 있음
- 이렇게 하면 기본적으로 등록되는 WebFlux 핵심 빈을 직접 재정의하거나 추가할 수 있음 