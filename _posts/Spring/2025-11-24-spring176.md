---
layout: post
title: WebFlux Config
date: 2025-11-24 09:00:00 +09:00
categories: [Spring, Reactive Stack, View Technologies]
tags: [spring]
image:
    path: /assets/img/spring/Spring.png
---

## 개요

- WebFlux를 사용하면 어노테이션 기반 컨트롤러 또는 함수형 엔드포인트를 처리하기 위한 필수 컴포넌트들이 자동 등록됨
- 기본적으로 빈이 일일이 설정할 필요없이, `WebFluxConfigurer`를 구현해서 필요한 부분만 오버라이드해서 커스터마이징 가능
- 고급 설정이 필요하면 `@EnableWebFlux` 대신 `DelegationWebFluxConfiguration`을 상송하는 고급 모드 사용도 가능함

<hr>

## WebFlux 설정 활성화 (`@EnableWebFlux`)

- Java 설정에서 `@EnableWebFlux`를 붙여 WebFlux 환경을 활성화할 수 있음
- Spring boot를 쓴다면, `WebFluxConfigurer` 구현체만 두고 `@EnableWebFlux`는 생략하는 방식으로도 Boot 자동 설정을 유지할 수 있음

```java
@Configuration
@EnableWebFlux
public class WebConfig implements WebFluxConfigurer {
    // WebFluxConfigurer 메서드 오버라이드 가능
}
```

<hr>

## 변환(Converstion) / 포맷팅(Formatting)

- 기본적으로 숫자 타입, 날짜 타입 등에 대해 포매터가 등록되어 있음
- `addFormatters(FormatterRegistry registry)`를 통해 커스텀 변환기나 컨버터를 등록할 수 있음
- 날짜/시간 포맷을 ISO 포맷으로 강제하고 싶을 경우, `DateTimeFormatterRegistrar`를 사용


```java
@Configuration
public class WebConfig implements WebFluxConfigurer {
    @Override
    public void addFormatters(FormatterRegistry registry) {
        DateTimeFormatterRegistrar registrar = new DateTimeFormatterRegistrar();
        registrar.setUseIsoFormat(true);
        registrar.registerFormatters(registry);
    }
}
```

<hr>

## 검증(Validation)

- Bean Validation이 클래스 패스에 있으면, 기본으로 `LocalValidatorFactoryBean`이 글로벌 Validator로 등록됨
- `getValidator()` 메서드를 오버라이드해서 커스텀 Validator 빈을 지정할 수 있음
- 또한, `@InitBinder`를 사용하여 특정 컨트롤러에 로컬 Validator를 설정하는 것도 가능

<hr>

## 요청 컨텐츠 타입 결정

- WebFlux는 기본적으로 `Accept` 헤더를 보고 미디어 타입을 결정
- `configureContentTypeResolver(RequestedContentTypeResolverBuilder builder)`를 오버라이드해서 쿼리 파라미터 기반 콘텐츠 타입 결정 전략을 추가할 수 있음

```java
@Configuration
public class WebConfig implements WebFluxConfigurer {
    @Override
    public void configureContentTypeResolver(RequestedContentTypeResolverBuilder builder) {
        builder.parameterResolver("format"); // 예: ?format=json
    }
}
```

<hr>

## HTTP 메시지 코드(Message Codecs)

- `configureHttpMessageCodecs(ServerCodecConfigurer configurer)` 메서드를 통해 요청 및 응답 바디를 읽고 쓰는 리더/라이터를 설정 가능
- 예: `maxInMemorySize` 조절해서 메모리 버퍼 제한 설정

```java
@Configuration
public class WebConfug implements WebFluxConfigurer {
    @Override
    public void configureHttpMessageCodecs(ServerCodecConfigurer configurer) {
        configurer.defaultCodecs().maxInMemorySize(16 * 1024 * 1024); // 16MB
    }
}
```

<hr>

## View Resolver

- `configureViewResolvers(ViewResolverRegistry registry)`를 오버라이드해서 템플릿 기반 뷰, 컨텐츠 협상 뷰 등을 등록할 수 있음
  
```java
@Configuration
public class WebConfig implements WebFluxConfigurer {
    @Override
    public void configureViewResolvers(ViewResolverRegistry registry) {
        registry.freeMarker();
        registry.defaultViews(new HttpMessageWriterView(new Jackson2JsonEncoder()));
    }

    @Bean
    public FreeMarkerConfigurer freeMarkerConfigurer() {
        FreeMarkerConfigurer configurer = new FreeMarkerConfigurer();
        configurer.setTemplateLoaderPath("classpath:/templates");
        return configurer;
    }
}
```


<hr>

## 정적 리소스 처리

- `addResourceHandlers(ResourceHandlerRegistry registry)`로 정적 리소스를 서빙할 수 있음

```java
@Configuration
public class WebConfig implements WebFluxConfigurer {
    @Override
    public void addResourceHandlers(ResourceHandlerRegistry registry) {
        registry.addResourceHandler("/resources/**")
                .addResourceLocations("classpath:/static/", "/public/")
                .setCacheControl(CacheControl.maxAge(365, TimeUnit.DAYS));
    }
}
```

- 리소스 체닝도 지원: `VersionResourceResolver` 등을 사용해 버전된 리소스 URL을 설정할 수 있음
- `ResourceWebHandler` 빈을 통해 URL 재작성을 지원할 수 있음
  - 그러나 WebFlux에서는 MVC처럼 non-blocking 방식으로 뷰 템플릿 안에서 리소스 URL을 투명하게 재작성하는 방식은 제한적임