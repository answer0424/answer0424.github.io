---
layout: post
title: RSocket
date: 2025-11-26 09:00:00 +09:00
categories: [Spring, Reactive Stack]
tags: [spring]
image:
    path: /assets/img/spring/Spring.png
---

## 개요

- RSocket은 TCP, WebSocket 등 바이트 스트림 전송 위에서 동작하는 어플리케이션 프로토콜로서, 요청-응답, 요청-스트림, 채널, 파이어-앤-포겟 등 다양한 상호작용 모델을 지원
- Spring Framework는 RSocket을 위해 요청자 및 응답자를 위한 API를 제공하며, 리액터 기반으로 만들어져 리액티브 스트림 규격을 네트워크 경계까지 확장

<hr>

## 주요 특징

- 리액티브 스트림 시맨틱: 요청자와 응답자 간에 back-pressure 신호가 전송될 수 있음 ➡️ 네트워크/버퍼링 부담 감수
- 요청 임대, 세션 재개, 대형 메시지 다중화, 하트 비트 등의 고급 기능 지원

<hr>

## RSocketRequester

- 클라이언트/서버 양쪽에서 사용할 수 있는 fluent API

```java
RSocketRequester requester = RSocketRequester.builder()
    .tcp("localhost":, 7000);
```

```java
RSocketRequester requester = RSocketRequester.builder()
    .webSocket(URI.create("ws://localhost:8080/rsocket"));
```

<br>

#### 어노테이션 기반 핸들러

- `@MessageMapping`, `@ConnectMapping`, `@RSocketExchange` 등으로 RScoket 요청을 처리하는 메서드를 정의할 수 있음
- Java 인터페이스 기반으로 RSocket 서비스 선언도 가능함 (`@RSocketExchange`가 붙은 메서드 인터페이스 형태)

<hr>

## 예시 흐름

```java
requester.route("some.route")
    .data(payloadObject)
    .retrieveMono(ResponseType.class)
    .subscribe(...);

@MessageMapping("some.route")
Flux<ResponseType> handle(PayloadType data) {
    return Flux.just(...);
}
```

- 위 흐름은 요청 하나 ➡️ 응답 스트림 모델을 보여줌 

<hr>

## 적용 시 유의사항

- RSocket은 HTTP 기반 REST 통신과 구조가 다르므로, 요청 모델을 설계할 때 상호작용 모델을 명확히 해야 함
- Spring Boot나 Spring Security 등과 연동 시 자동 설정이나 보안 설정을 추가로 고려해야 함
- 데이터 및 메타데이터의 MIME 타입 설정, 인코더/디코더 전략 등을 적절히 구성해야 함