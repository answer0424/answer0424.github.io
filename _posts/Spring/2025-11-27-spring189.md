---
layout: post
title: Key Abstractions
date: 2025-11-27 09:00:00 +09:00
categories: [Spring, Testing]
tags: [spring]
image:
    path: /assets/img/spring/Spring.png
---

## 핵심 추상들

| 추상/클래스 | 역할/책임 |
|-|-|
| TestContext | 현재 테스트 실행에 대한 컨텍스트 정보를 캡슐화 - 즉, 테스트 실행환경을 가진 객체. 필요 시 `ApplicationContext`를 로드하거나 캐시에서 가져오는 역할 포함 |
| TestContextManager | `TestContext`를 관리하고, 테스트 실행의 각 단계에 맞춰 등록된 리스너들(`TestExecutionListener`)에게 이벤트를 전달하는 중추 엔진 |
| TestExecutionListener | 테스트 실행의 특정 단계에 개입할 수 있는 리스너 인터페이스. 의존성 주입, 트랜잭션 관리, 컨텍스트 초기화/종료, 커스텀 후처리 등 다양한 기능을 구현 가능 |
| SmartContextLoader | 테스트 클래스의 설정을 보고 `ApplicationContext`를 생성해주는 전략. 즉, 어떤 빈 설정을 불러올지 판단하고 컨텍스트를 로드하는 책임자 |

<hr>

## 동작 흐름

1. 테스트 클래스 단위로 `TestContextManager` 생성 ➡️ 이 안에 `TestContext` 인스턴스 포함
2. 테스트 실행 전후, lifecycle 지점마다 `TestContextManager`가 `TestExecutionListener`들에 이벤트를 보내서 설정, DI, 트랜잭션 설정, 리소스 초기화/정리 등을 수행
3. 만약 테스트에서 `ApplicationContext`가 필요하면 - `SmartContextLoader`가 호출되어 `ApplicationContext`를 로드 혹은 캐시된 컨텍스트를 재사용 

<hr>

## 추상 구조가 필요한 이유

- 테스트 프레임워크 독립성: `TestContext` 등은 JUnit, TestNG 등 구체 테스트 프레임워크에 의존하지 않는 구조라서, Spring의 테스트 인프라를 어떤 프레임워크에서도 동일하게 사용할 수 있게 해줌
- 컨텍스트 캐싱 + 재사용: 매 테스트마다 스프링 컨텍스트를 다시 만들면 느리지만, 같은 설정이라면 캐시된 컨텍스를 재사용 가능
- 확장성 & 커스터마이즈: `TestExecutionListener`와 `SmartContextLoader`를 커스터마이즈하면, 테스트 실행 흐름에 별도 로직을 삽입 가능
- 통합 테스트의 일관성 + 편의성: DI, 트랜잭션, 빈 설정, 웹 계층 등 복잡한 설정이 있는 어플리케이션을 테스트할 때 반복되는 설정을 프레임 워크가 대신 해줌 

<hr>

## 예시

```java
@ExtendWith(SpringExtension.class)  // JUnit 5 + Spring 통합
@ContextConfiguration(classes = {AppConfig.class})  // SmartContextLoader가 이 설정 사용
public class MyServiceIntegrationTest {

    @Autowired
    private MyService service;

    @BeforeEach
    void setUp() {
        // TestContextManager가 @Autowired 처리 + DI 해줌
    }

    @Test
    void testLogic() {
        // service를 이용한 테스트
    }
}
```

- 위처럼 테스트 클래스에 특별한 베이스 클래스를 상속하지 않아도 되고, 단순 POJO 클래스로 테스트 작성 가능
- 이는 TestContext Framework가 내부에서 `TestContextManager`, `TestExecutionListener`, `SmartContextLoader`를 이용해 컨텍스트 설정, DI, 트랜잭션 등을 자동으로 처리해주기 때문

<hr>

## 주의사항 

- 빈 설정을 바꾼 테스트: 만약 테스트 중에 빈 설정을 변경하거나 ApplicationContext에 영향을 주는 코드를 실행한다면 - 캐시된 컨텍스트를 재사용하면 안될 수 있음
- 병렬 테스트 실행 시 주의: TestContext 구현체는 병렬 실행을 위해 복사 생성자를 제공하는 것이 권장됨
- 커스텀 리스너/로더 구현 시 확장성 고려: 만약 테스트 실행 흐름을 제어하거나, 컨텍스트 로딩 방식을 커스터마이즈해야 한다면 `TestExecutionListener` 또는 `SmartContextLoader`를 구현해 등록할 수 있음
- 테스트 환경 독립성 유지: 캐시된 ApplicationContext를 여러 테스트에서 재사용하므로, 테스트 간에 상태가 공유되지 않도록 유의해야 함 