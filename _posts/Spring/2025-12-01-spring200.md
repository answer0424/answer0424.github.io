---
layout: post
title: Context Configuration with Component Classes
date: 2025-12-01 09:00:00 +09:00
categories: [Spring, Testing, TestContext Framework, Context Management]
tags: [spring]
image:
    path: /assets/img/spring/Spring.png
---


## 개요

- Spring에서는 설정을 XML이나 Groovy DSL뿐만 아니라 자바 코드를 이용해 정의할 수 있음
- TestContext Framework도 이 Java 기반 설정을 그대로 사용해서 테스트용 `ApplicationContext`를 로드하도록 지원함
- 테스트 클래스는 특별히 어떤 베이스 클래스를 상속받을 필요없이, 단지 `@ContextConfiguration(classes=...)`등의 어노테이션으로 설정 클래스를 지정하면 됨

<hr>

## 설정 방법 - `@ContextConfiguration`

#### 예시

```java
@ExtendWith(SpringExtension.class)  // JUnit 5 사용 시 Spring 연동
@ContextConfiguration(classes = {AppConfig.class, TestConfig.class})
public class MyTest {
    // 테스트 코드 …
}
```

<br>

#### Nasted 설정 클래스 사용하기

```java
@SpringJUnitConfig  // @ExtendWith + @ContextConfiguration 포함 축약 어노테이션
public class OrderServiceTest {

    @Configuration
    static class Config {
        @Bean
        OrderService orderService() {
            return new OrderServiceImpl();
        }
    }

    @Autowired
    OrderService orderService;

    @Test
    void testOrderService() {
        // orderService 테스트
    }
}
```

> 위처럼 테스트 클래스 안에 설정 클래스를 두면, 그 설정만으로 `ApplicationContext`를 로드 가능

<hr>

## 어떤 클래스가 컴포넌트 클래스가 될 수 있나

- `@ContextConfiguration(classes=...)`에 지정할 수 있는 클래스의 유형은 다양함
    - `@Configuration`이 붙은 설정 클래스 
    - `@Component`, `@Service`, `@Repository` 등 steretype 어노테이션이 붙은 클래스
    - JSR-330 기반 빈 클래스
    - `@Bean` 메서드를 가진 클래스
    - 또는 단일 생성자 + 자동 주입 등, Spring이 자동 빈으로 인식할 수 있는 일반 클래스

> 즉, 굳이 `@Configuration` 메타를 붙이지 않아도 빈으로 쓸만한 클래스라면 component class로 사용 가능

<hr>

## 예제

```java
@Configuration
public class ServiceConfig {
    @Bean
    public MyService myService(MyRepository myRepository) {
        return new MyServiceImpl(myRepository);
    }

    @Bean
    public MyRepository myRepository(DataSource dataSource) {
        return new MyRepositoryImpl(dataSource);
    }
}

@Configuration
public class TestDataSourceConfig {
    @Bean
    public DataSource dataSource() {
        return new EmbeddedDatabaseBuilder()
            .setType(EmbeddedDatabaseType.H2)
            .build();
    }
}
```

> 위 설정을 테스트에 적용

```java
@ExtendWith(SpringExtension.class)
@ContextConfiguration(classes = {ServiceConfig.class, TestDataSourceConfig.class})
public class MyServiceIntegrationTest {
    @Autowired
    private MyService myService;

    @Test
    void testBusinessLogic() {
        // myService 테스트 코드 …
    }
}
```

> 이렇게 하면 Service layer + Repository + DataSource 모두 JavaConfig 기반으로 설정된 상태에서, 실제처럼 bean 주입, DataSource, 트랜잭션 등 포함한 테스트 수행 가능 

<hr>

## TestContext의 Context 재사용 & 캐싱 동작

- Spring TestContext는 한 번 로드된 `ApplicationContext`를 구성 조건이 동일한 테스트들 간에 재사용함
  - 이 덕분에 여러 테스트 클래스나 여러 테스트 메서드에서 반복적으로 context를 생성할 필요없이 테스트 속도가 훨씬 빨라짐
- 캐싱 키로는 `@ContextConfiguration`의 `classes`, `locations`, `contextInitializers`, `active profile`, `customizer`, `parent context` 등 여러 설정 요소가 고려됨
- 따라서 같은 설정을 공유하는 테스트는 서로 context를 함께 쓰게 되므로, 테스트 간 상태 공유에 유의해야 함
  - 테스트 중 bean 상태를 변경하거나 mock/spy를 사용한다면, `@DirtiesContext` 등을 통해 다음 테스트는 새 컨텍스트를 로드하도록 표시하는 것이 권장됨