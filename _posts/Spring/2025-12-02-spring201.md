---
layout: post
title: Context Configuration with Component Classes
date: 2025-12-01 09:00:00 +09:00
categories: [Spring, Testing, TestContext Framework, Context Management]
tags: [spring]
image:
    path: /assets/img/spring/Spring.png
---

## 개념

- ContextCustomizer는 Spring의 테스트 컨텍스트가 생성하는 `ApplicationContext`를 , Bean 정의 로딩 후 & 컨텍스트 리프레시 전에 프로그래밍 방식으로 커스터마이즈할 수 있게 해주는 전략 인터페이스
- 단, ContextCustomizer 자체는 직접 등록되는 게 아니라, ContextCustomizerFactory가 이 테스트 클래스에 이런 customizer를 적용할지 결정하고 생성함
- 즉, 요약하면
  - Bean 정의는 설정 + 자동 스캔 등 일반 방식으로 읽고 난 뒤 ContextCustomizer를 통해 추가 설정, 프로퍼티 주입, 빈 오버라이드, 조건부 빈 등록 등을 동적으로 할 수 있음 

<hr>

## 왜 / 언제 ContextCustomizer를 사용하나

- 테스트마다 조금씩 다른 설정을 주고 싶을 때
- 예: 현재 시간을 고정된 값으로 설정, 특정 프로퍼티만 테스트에서 바꾸기, 테스트 전용 빈 오버라이드 등 테스트 환경을 동적으로 변경하고 싶을 때
- 여러 테스트 클래스가 있지만 공통 customizer를 적용하고자 할 때 - 중복 설정 방지, 유지보수 효율성 향상
- 설정 로직이 복잡하거나 반복되는 경우, customizer로 캡슐화해서 재사용할 수 있다는 점도 장점

<hr>

## 어떻게 설정/사용하는가

#### 1. ContextCustomizer 구현

```java
public class MyContextCustomizer implements ContextCustomizer {
    @Override
    public void customizeContext(ConfigurableApplicationContext ctx, MergedContextConfiguration config) {
        TestPropertyValues.of("my.property=someValue").applyTo(ctx.getEnvironment());
    }

    @Override
    public boolean equals(Object o) { /* ... */ }
    @Override
    public int hashCode() { /* ... */ }
}
```

<br>

#### 2. ContextCustomizerFactory 구현

```java
public class MyCustomizerFactory implements ContextCustomizerFactory {
    @Override
    public ContextCustomizer createContextCustomizer(Class<?> testClass,
            List<ContextConfigurationAttributes> configAttributes) {
        if (testClass.isAnnotationPresent(MyTestConfigMarker.class)) {
            return new MyContextCustomizer();
        }
        return null;
    }
}
```

<br>

#### 3. Factory 등록

- 테스트 클래스 레벨에서만 쓰고 싶다면, `@ContextCustomizerFactories` 어노테이션을 사용해 등록
- 프로젝트 전반에 쓰고 싶다면 `META-INF/spring.factories`에 등록

<br>

#### 4. 테스트 실행 시 동작 흐름

- `ContextLoader`가 설정 + 빈 정의 로드
- `ContextCustomizerFactory`들이 적용 대상인지 검사 ➡️ customizer 생성
- `ContextCustomizer.customizeContext()` 호출 ➡️ context 환경 / 빈 구성 변경
- context refresh ➡️ Spring context 정상 구동

<hr>

## 주의할 점

- `ContextCustomizer` 구현체는 올바른 `equals()` / `hashCode()` 구현이 반드시 필요
  - 이유: customizer가 테스트 컨텍스트 캐시의 일부로 쓰이기 때문
  - 너무 자주, 너무 복잡하게 customizer를 남발할 경우 결과적으로 여러 variant의 컨텍스트가 캐시되고 테스트 전체 속도가 느려질 수 있음
- 설정이 customizer + 기존 설정 + mock/spy + 프로퍼티 등으로 복잡해질수록 어떤 설정이 최종 반영되었는지 추적이 어려울 수 있음
- customizer의 책임이 많아질 경우, context 초기화 타이밍이나 lifecycle-anchor 지점 등을 잘 이해하고 써야 함