---
layout: post
title: Dependency Injection of Test
date: 2025-12-03 09:00:00 +09:00
categories: [Spring, Testing, TestContext Framework]
tags: [spring]
image:
    path: /assets/img/spring/Spring.png
---

## 주입 방식 & 조건

| 주입 방식 | 설명 / 주의점 |
|-|-|
| 필드 주입 | 테스트 클래스 내부에 `@Autowired` 또는 `@Inject` 붙인 필드 선언 - 가장 흔한 방식 |
| Setter 주입 | 필드 대신 setter 메서드에 어노테이션 붙여 주입 가능 DI 방식에 맞게 설계할 때 사용 |
| 생성자 주입 | JUint Jupiter + SpringExtension 조합일 때 가능 |
| 명시적 빈 조회 | 만약 타입이 중복되거나 어떤 빈을 DI로 주입받기 어려울 경우 테스트 내에서 직접 `applicationContext.getBean(...)` 호출 가능 |

<hr>

## 장점

- 픽스처 설정 반복 제거: 테스트마다 복잡한 객체 생성 대신, Spring 설정에 정의된 빈을 재사용 - 설정 중복 방지
- IoC 컨테이너 + DI의 이점 활용: 서비스, 리포지토리, DataSource, 트랜잭션 매니저 등 복잡한 의존성이 얽힌 객체들도 설정만 해두면 테스트 클래스에서는 단순히 `@Autowired`만으로 주입 가능
- 테스트 코드 간 결합도 낮춤: 테스트 클래스와 빈 구성을 분리 - production config나 테스트 config를 재사용하면서 테스트 작성 가능
- 통합 테스트 편의성: 특히 데이터베이스 , JPA, DAO/Repository, 서비스 계층의 통합 동작을 테스트할 때 유용

<hr>

## 주의할 점

- 동일 타입 빈 여러 개 있을 경우 ambiguity 발생 - 단순 `@Autowired`로는  어느 빈을 주입받을지 알 수 없음
- 테스트 프레임워크/러너 제약 - JUnit Jupiter + SpringExtension 조합이 아닐 경우 생성자 주입이 동작하지 않을 수 있음
- 테스트 격리 주의 - 빈의 상태나 캐싱된 리소스를 테스트 간에 공유할 수 있으므로, 상태 변화가 있는 bean이나 static 자원, 싱글톤 빈을 사용할 때 ㄴ테스트 간 간섭 주의
- 과도한 DI 남용 경계 - 테스트가 너무 복잡하고 많은 빈에 의존적이며, 테스트 유지보수가 어려워질 수 있음 

<hr>

## 예제

```java
// src/test/java/com/example/MyServiceTest.java

@SpringJUnitConfig(AppConfig.class)  // @ExtendWith + @ContextConfiguration 포함
class MyServiceTest {

    @Autowired
    private MyService myService;  // test fixture

    @Test
    void testDoSomething() {
        String result = myService.doSomething();
        assertNotNull(result);
    }
}
```

- `AppConfig` 클래스 안에 `MyService` 빈 + 의존 빈 설정이 있다고 가정
- 테스트에서 별도 인스턴스 생성 없이, 스프링이 관리하는 빈이 주입되어 바로 사용됨