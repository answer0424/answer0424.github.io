---
layout: post
title: Bean Overriding in Tests
date: 2025-12-04 09:00:00 +09:00
categories: [Spring, Testing, TestContext Framework]
tags: [spring]
image:
    path: /assets/img/spring/Spring.png
---

## 개념

- 테스트를 할 때, 원래 어플리케이션 컨텍스트에 정의된 빈을 테스트 전용 빈으로 대체하거나, 새 빈을 추가하는 기능을 말함
  - 즉, 프로덕션 설정을 그대로 두면서 테스트용으로 일부 빈을 override 하거나 substitute 할 수 있음
- 이 기능은 `beanFactory.setAllowBeanDefinitionOverriding(true)`와 같은 전역 설정 대신 - 테스트에 국한된 안전한 방식으로 제공
  - 즉, 테스트 컨텍스트 구성 시에만 빈을 재정의하도록 설계
- 프레임워크는 두 주요 방식의 bean-override 어노테이션을 제공
  - `@TestBean` - Spring 기반
  - `@MockBean` / `@MockitoBean` - Mockito 기반 mock/spy 빈으로 대체하기 위한 어노테이션
- 내부적으로 `@BeanOverride` 메타어노테이션 + `BeanOverrideProcessor` + `ContextCutomizerFactory` + `TestExecutionListener` 기반 인프라가 작동하여, 테스트용 컨텍스트가 로드되기 전에 빈 정의를 대체하거나 추가함
- 대체 방식
  - **REPLACE**: 기존 빈을 대체
  - **REPLCAE_OR_CREATE**: 기존 빈이 있으면 대체, 없으면 새로 생성
  - **WRAP**: 원래 빈을 감싸거나 래핑하도록 변경
- 중요한 점: 만약 원래 빈이 prototype이거나 FactoryBean을 통해 생성된 빈이면, override 후에는 대신 singleton 빈으로 바뀔 수 있음

<hr>

## 예시 & 방법

#### `@TestBean` 사용 예시

```java
@SpringBootTest
class MyServiceIntegrationTest {

    @TestBean
    private MyService myService;  // 이 빈을 override

    static MyService myService() {
        return new MyFakeService();  // 테스트용 대체 구현
    }

    @Autowired
    private SomeClient client;

    @Test
    void testSomething() {
        // 빈 myService 는 Fake 구현으로 설정된 상태
        // 테스트 실행
    }
}
```

- 위 예시에서, `@TestBean`은 non-static 필드에 붙이며, 같은 이름의 static factory 메서드에서 실제 빈 인스턴스를 생성해서 override 함
- 빈을 이름 또는 타입 기반으로 결정하며, 만약 동일 타입의 빈이 여러 개라면 `@Qualifier`를 사용해 구분 가능
- 만약 해당 빈이 원래 존재하지 않는 경우에도 새로 만들어지며, 테스트가 실패하지 않고 빈이 주입됨

<hr>

## `@MockitoBean` / `@MockitoSpyBean` 사용 예

- Mockito 기반 mocking/spy를 테스트 컨텍스트 빈으로 등록하고 싶을 때 사용
- 내부적으로 같은 bean override 인프라를 사용하므로, TestContext의 캐싱 + 재사용 이점을 유지하면서 mock 삽입 가능

<hr>

## 유의사항

- override 대상 빈이 prototype scope 또는 FactoryBean 기반이라면, override 후엔 singleton 빈으로 바뀔 수 있고 이로 인해 예상치 못한 동작이나 상태 공유가 생길 수 있음
- 여러 빈 candidates가 있을 때 타입만으로는 어떤 빈을 override 할지 모호하면, `@Qualifier` 또는 `@TestBean(name="...")`을 명시해야 함
- 만약 어플리케이션이 여러 컨텍스트 계층을 사용하고 있다면, `@TestBean`은 모든 계층에 적용될 수 있어서 의도치 않은 빈 덮어쓰기가 발생할 수 있음
- Bean overriding은 편리하지만 테스트 전용 환경이라는 것을 명확히 해야 함
  - production 코드에서는 같은 이름의 빈이 중복되면 예외가 나거나 충돌이 발생할 수 있으므로, overriding을 테스트에만 제한해야 함
- override된 빈을 사용할 경우, TestContext의 컨텍스트 캐싱에 영향을 줄 수 있음
  - override 조건이 다르면 새로운 컨텍스트가 생성되어 캐싱 효과가 떨어질 수 있음

<hr>

## 유용할 때

- 실제 의존하고 있는 외부 시스템, API, DB, 메시징 시스템 등 - 통합 테스트 또는 단위 테스트에서 격리하고 싶을 때
- production 빈을 그대로 쓰되, 일부 빈만 stub/spy/대체 구현으로 교체하여 테스트의 집중도를 높이고 싶을 때
- 테스트 전용 설정 분리 - 예: 서비스 로직은 production 설정 유지, repository만 테스트용 in-memory DB로 대체
- 여러 테스트에서 공통 컨텍스트를 캐싱 + 재사용하면서, 특정 테스트만 빈을 override하고 싶을 때 