---
layout: post
title: Defining Expectations
date: 2025-12-11 09:00:00 +09:00
categories: [Spring, Testing, TestContext Framework, MockMvc, AssertJ]
tags: [spring]
image:
    path: /assets/img/spring/Spring.png
---

## 개요

- MockMvc 기반 테스트에서, Hamcrest matcher + `.andExpect()` 방식 대신 AssertJ 스타일의 fluent API + assertion chain으로 검증할 수 있도록 해주는 게 MockMvcTester + AssertJ 통합
- static import 없이도 직관적이고 간결한 검증 코드 작성 가능
- 예외 처리 없이 테스트 코드를 깔끔히 유지 가능
- 비동기 요청도 기본적으로 완료된 결과를 기다려주기 떄문에 별도 async-dispatch 처리가 필요 없음
- 테스트 결과는 `MvcTestResult` / `MvcTestResultAssert` 등의 AssertJ-friendly 객체로 표현되며, 표준 `assertThat()` 구문을 사용할 수 있음

<hr>

## 지원되는 검증 항목들

| 검증 대상 / 항목 | 설명 |
|-|-|
| HTTP 응답 상태 | `hasStatusOk()` 처럼, 응답 상태가 200 OK인지 확인 가능한 메서드 제공 |
| 응답 Content-Type/헤더 | 예: `hasContentTypeCompatibleWith(MediaType.APPLICATION_JSON)` 같이 응답 `Content-Type` 헤더를 검사 가능 |
| 본문 - JSON, 텍스트 등 | `bodyJson()` 등을 통해 JSON 응답 본문을 AssertJ-friendly 방식으로 읽고, JSON 구조/값을 검증 가능 |
| 쿠키 | 응답에 포함된 쿠키를 검증하기 위한 assertion 객체 지원 |\
| 모델, 뷰, 핸드러 정보 | 만약 controller에서 모델/뷰 반환 형태라면, `hasViewName()` 또는 모델 속성 assertion, 핸들러 정보 assertion 등을 사용할 수 있음 |
| 요청, 응답 객체 속성 | 요청 객체나 응답 객체 자체에 대해 AssertJ assertions 사용 가능 |
| 비동기 처리 결과 | MockMvcTester는 async 요청도 기본으로 완료된 결과를 반환하므로, 별도 async-dispatch 없이 동일한 assertion API로 처리 가능 |

> 즉, 기존 Hamcrest + `andExpect()`로 할 수 있었던 대부분의 검증을 그리고 더 읽기 쉽고 유지보수하기 좋은 방식으로 AssertJ를 통해 수행 가능하다는 뜻

<hr>

## 예제

```java
assertThat(mockMvc.get().uri("/hotels/{id}", 42))
    .hasStatusOk()
    .hasContentTypeCompatibleWith(MediaType.APPLICATION_JSON)
    .bodyJson().isLenientEqualsTo("sample/hotel-42.json");
```

- 검증 대상
  - `/hotels/42` GET 요청의 응답
  - 응답 상태가 200 OK인지
  - 응답 Content-Type이 JSON인지
  - 응답 본문이 `sample/hotel-42.json` 파일과 lenient 모드로 동일한지

<hr>

## 장점

- static import 불필요: Hamcrest 방식에 비해 import 부담이 줄어듦
- 예외 처리 단순화: 테스트 메서드에 `throws Exception` 선언 없이도 깔끔하게 작성 가능
- 동기/비동기 요청 일관된 처리: async 요청도 별도 코드 없이 자연스럽게 assertion 가능
- 가독성 & 유지보수성 향상: fluent API + AssertJ assertion 덕분에, 복잡한 JSON 구조나 응답 속성 검증 시 코드가 읽기 쉽고 수정/확장도 용이

<hr>

## 사용 시기

- 복잡한 JSON 응답을 많이 검증해야 할 때 - JSON 구조, 필드, 타입 일치 등 간결하게 체크하고 싶을 때
- MVC-layer 테스트에서 응답 상태 + 헤더 + 모델/뷰 정보 등 다양한 항목을 조합해서 검증할 때
- 테스트 코드의 가독성과 유지보수성을 중시할 때 - 특히 팀 단위, 장기 유지보수되는 프로젝트라면 가독성 측면에서 큰 장점
- 비동기 처리 - `DeferredResult`, `Mono`, `Flux`, `Callable` 등 사용 시, async dispatch 신경쓰지 않고도 테스트하고 싶을 때