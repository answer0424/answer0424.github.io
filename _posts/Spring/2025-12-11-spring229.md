---
layout: post
title: MockMvc integration
date: 2025-12-11 09:00:00 +09:00
categories: [Spring, Testing, TestContext Framework, MockMvc, AssertJ]
tags: [spring]
image:
    path: /assets/img/spring/Spring.png
---

## 개요

- 만약 기존에 MockMvc API를 사용하고 있었다면 `MockMvcTester`를 어떻게 기존 MockMvc와 함께 쓸 수 있는지 설명
- 즉, 완전히 새 방식으로 전환하지 않으면서도, 기존 MockMvc 기반 테스트 + AssertJ assertion 스타일을 혼합해서 사용할 수 있게 해주는 브리지 방법
- 주요 핵심
  - 기존 MockMvc의 `RequestBuilder` + `perform()`을 그대로 사용하면서, 결과에 대해 AssertJ 스타일로 검증 가능
  - 또한 기존의 custom `ResultMatcher`/`ResultHandler`를 `MockMvcTester` + AssertJ 환경에서도 재사용할 수 있게 해주는 메서드 제동


<hr>

## 통합 사용 가능 시나리오

`MockMvcTester` + `MockMvc` 통합은 다음 같은 경우에 유용

- 기존에 `MockMvc` + `Hamcrest matcher` 기반 테스트가 많고 완전히 새 스타일로 바꾸기 부담될 때
- 일부 테스트느 기존 방식을 유지하면서, 새로운 테스트만 AssertJ 방식으로 작성하고 싶을 떄
- 프로젝트 규모가 크거나 테스트 커버리지가 넓어서 점진적 전환이 필요할 때

<hr>

## 주요 방법

#### 기존 RequestBuilder + perform() ➡️ AssertJ assertion

```java
// static import on MockMvcRequestBuilders.get
assertThat(mockMvc.perform(get("/hotels/{id}", 42)))
    .hasStatusOk();
```

- 즉, 기존 `get()`, `post()` 등과 `perform()` 조합을 유지하되, 결과에 대해 AssertJ `assertThat()` + `hasStatusOk()` 같은 assertion 사용

<br>

#### 기존 custom ResultMatcher + matches()

- 만약 기존에 `.andExpect()`안에 custom `ResultMatcher`를 사용했다면, 이를 `MockMvcTester` 환경에서도 다음처럼 재사용 가능

```java
assertThat(mockMvc.get().uri("/hotels/{id}", 42))
    .matches(status().isOk());
```

- 즉, Hamcrest matcher 기반의 매처를 그대로 쓰면서 AssertJ wrapper 안에서 적용 가능

<hr>

## 장점

- 점진적 도입 가능: 기존 MockMvc 기반 테스트가 많아도 큰 리팩토링 없이 일부만 AssertJ 방식으로 전환 가능
- 유연성: 기존 Hamcrest 기반 custom matcher, custom handler 등을 버리지 않고 그대로 사용할 수 있음
- 가독성 + 유지보수성: 새로 작성하는 테스트에 대해 AssertJ + fluent API 스타일을 적용하면 더 깔끔하고 직관적인 assertion 문법을 쓸 수 있음
- AssertJ 스타일 + MockMvc 환경의 장점을 모두 확보: 즉, Spring MVC mock environment, plus AssertJ의 표현력 및 친숙함

<hr>

## 고려할 점

- 섞어서 사용하면 테스트 스타일이 통일되지 않을 수 있음
- custom matcher/handler를 많이 쓰는 경우 적절히 감싸주지 않으면 가독성이 오히려 떨어질 수 있음
- 완전히 새로운 기능을 활용하려면 기존 코드 일부는 rewrite 필요