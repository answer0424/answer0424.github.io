---
layout: post
title: MockMvc integration
date: 2025-12-11 09:00:00 +09:00
categories: [Spring, Testing, TestContext Framework, MockMvc, AssertJ]
tags: [spring]
image:
    path: /assets/img/spring/Spring.png
---

## 개요

- 만약 기존에 MockMvc API를 사용하고 있었다면 `MockMvcTester`를 어떻게 기존 MockMvc와 함께 쓸 수 있는지 설명
- 즉, 완전히 새 방식으로 전환하지 않으면서도, 기존 MockMvc 기반 테스트 + AssertJ assertion 스타일을 혼합해서 사용할 수 있게 해주는 브리지 방법
- 주요 핵심
  - 기존 MockMvc의 `RequestBuilder` + `perform()`을 그대로 사용하면서, 결과에 대해 AssertJ 스타일로 검증 가능
  - 또한 기존의 custom `ResultMatcher`/`ResultHandler`를 `MockMvcTester` + AssertJ 환경에서도 재사용할 수 있게 해주는 메서드 제동


<hr>

## 통합 사용 가능 시나리오

`MockMvcTester` + `MockMvc` 통합은 다음 같은 경우에 유용

- 기존에 `MockMvc` + `Hamcrest matcher` 기반 테스트가 많고 완전히 새 스타일로 바꾸기 부담될 때
- 일부 테스트느 기존 방식을 유지하면서, 새로운 테스트만 AssertJ 방식으로 작성하고 싶을 떄
- 프로젝트 규모가 크거나 테스트 커버리지가 넓어서 점진적 전환이 필요할 때

<hr>

## 주요 방법

#### 기존 RequestBuilder + perform() ➡️ AssertJ assertion

```java
// static import on MockMvcRequestBuilders.get
assertThat(mockMvc.perform(get("/hotels/{id}", 42)))
    .hasStatusOk();
```

- 즉, 기존 `get()`, `post()` 등과 `perform()` 조합을 유지하되, 결과에 대해 AssertJ `assertThat()` + `hasStatusOk()` 같은 assertion 사용

<br>

#### 기존 custom ResultMatcher + matches()

- 만약 기존에 `.andExpect()`안에 custom `ResultMatcher`를 사용했다면, 이를 `MockMvcTester` 환경에서도 다음처럼 재사용 가능

```java
assertThat(mockMvc.get().uri("/hotels/{id}", 42))
    .matches(status().isOk());
```

- 즉, Hamcrest matcher 기반의 매처를 그대로 쓰면서 AssertJ wrapper 안에서 적용 가능

<hr