

<feed xmlns="http://www.w3.org/2005/Atom">
  <id>http://localhost:4000/</id>
  <title>answer</title>
  <subtitle>A minimal, responsive and feature-rich Jekyll theme for technical writing.</subtitle>
  <updated>2025-02-15T10:36:30+09:00</updated>
  <author>
    <name>코드로 답하다</name>
    <uri>http://localhost:4000/</uri>
  </author>
  <link rel="self" type="application/atom+xml" href="http://localhost:4000/feed.xml"/>
  <link rel="alternate" type="text/html" hreflang="en"
    href="http://localhost:4000/"/>
  <generator uri="https://jekyllrb.com/" version="4.4.1">Jekyll</generator>
  <rights> © 2025 코드로 답하다 </rights>
  <icon>/assets/img/favicons/favicon.ico</icon>
  <logo>/assets/img/favicons/favicon-96x96.png</logo>


  
  <entry>
    <title>Form</title>
    <link href="http://localhost:4000/posts/React10/" rel="alternate" type="text/html" title="Form" />
    <published>2025-02-14T08:40:00+09:00</published>
  
    <updated>2025-02-14T08:40:00+09:00</updated>
  
    <id>http://localhost:4000/posts/React10/</id>
    <content type="text/html" src="http://localhost:4000/posts/React10/" />
    <author>
      <name>코드로 답하다</name>
    </author>

  
    
    <category term="React" />
    
    <category term="initial" />
    
  

  <summary>폼 상태 관리    React에서는 폼 상태를 관리하기 위해 useState 훅을 자주 사용한다     import React, { useState } from &amp;#39;react&amp;#39;;  const MyForm = () =&amp;amp;gt; {   const [name, setName] = useState(&amp;#39;&amp;#39;);    const handleChange = (event) =&amp;amp;gt; {     setName(event.target.value);   }    const handleSubmit = (event) =&amp;amp;gt; {     event.preventDefault();     alert(`Submitted Name: ${name}`);   }    return (     &amp;amp;lt;form onSubmit={handleSub...</summary>

  </entry>

  
  <entry>
    <title>useReducer</title>
    <link href="http://localhost:4000/posts/React09/" rel="alternate" type="text/html" title="useReducer" />
    <published>2025-02-13T08:36:00+09:00</published>
  
    <updated>2025-02-13T08:49:11+09:00</updated>
  
    <id>http://localhost:4000/posts/React09/</id>
    <content type="text/html" src="http://localhost:4000/posts/React09/" />
    <author>
      <name>코드로 답하다</name>
    </author>

  
    
    <category term="React" />
    
    <category term="hook" />
    
  

  <summary>useReducer    상태 업데이트 로직이 복잡할 때 사용되는 리엑트 훅 주로 Redux와 같은 패턴에서 영감을 받았다 상태와 상태 업데이트 함수를 반환하는데 이를 통해 복잡한 상태 로직을 보다 직관적으로 관리할 수 있다     기본 사용법 const [state, dispatch] = useReducer(reducer, initialState);     reducer : 상태를 업데이트하는 함수, 두 개의 인자를 받는다   initialState : 초기 상태 값     예제    reducer 함수 : 상태 업데이트 로직을 정의한다     function reducer(state, action) {   switch (action.type) {  case &amp;#39;increment&amp;#39;:    return ...</summary>

  </entry>

  
  <entry>
    <title>useContext</title>
    <link href="http://localhost:4000/posts/React08/" rel="alternate" type="text/html" title="useContext" />
    <published>2025-02-12T08:43:00+09:00</published>
  
    <updated>2025-02-13T08:44:49+09:00</updated>
  
    <id>http://localhost:4000/posts/React08/</id>
    <content type="text/html" src="http://localhost:4000/posts/React08/" />
    <author>
      <name>코드로 답하다</name>
    </author>

  
    
    <category term="React" />
    
    <category term="hook" />
    
  

  <summary>useContext    Context API를 통해 전역 상태를 쉽게 관리하고 접근할 수 있도록 도와준다 Context API는 컴포넌트 트리 전체에서 데이터를 전달하는 간편한 방법을 제공한다     사용법 const value = useContext(MyContext);     Context API의 구성 요소    Context 객체 생성 : React.createContext()를 사용하여 Context 객체를 생성한다     const MyContext = React.createContext(defaultValue);           Provider : Context를 통해 하위 컴포넌트에게 값을 제공하는 컴포넌트 ```javascript  &amp;amp;lt;MyContext.Provider value...</summary>

  </entry>

  
  <entry>
    <title>useRef</title>
    <link href="http://localhost:4000/posts/React07/" rel="alternate" type="text/html" title="useRef" />
    <published>2025-02-12T08:43:00+09:00</published>
  
    <updated>2025-02-13T08:42:55+09:00</updated>
  
    <id>http://localhost:4000/posts/React07/</id>
    <content type="text/html" src="http://localhost:4000/posts/React07/" />
    <author>
      <name>코드로 답하다</name>
    </author>

  
    
    <category term="React" />
    
    <category term="hook" />
    
  

  <summary>useRef    DOM 요소나 저장 공간을 직접 참조할 수 있게 해준다 이는 클래스형 컴포넌트에서 사용되던 ref와 유사한 기능을 함수형 컴포넌트에서 사용할 수 있도록 도와준다     사용법 const myRef = useRef(initialValue);     initialValue는 useRef로 생성된 객체의 초기값을 설정한다     주요 포인트    DOM 접근            useRef는 DOM요소에 직접 접근할 수 있도록 해준다       이를 통해 특정 DOM 요소를 조작하거나 상태를 확인할 수 있다           상태 유지            컴포넌트가 다시 렌더링 될 때에도 useRef로 생성된 객체는 값을 유지한다       이는 재렌더링 시 값이 초기화되지 않아야 하는 경...</summary>

  </entry>

  
  <entry>
    <title>useMemo</title>
    <link href="http://localhost:4000/posts/React06/" rel="alternate" type="text/html" title="useMemo" />
    <published>2025-02-12T08:30:00+09:00</published>
  
    <updated>2025-02-13T08:42:55+09:00</updated>
  
    <id>http://localhost:4000/posts/React06/</id>
    <content type="text/html" src="http://localhost:4000/posts/React06/" />
    <author>
      <name>코드로 답하다</name>
    </author>

  
    
    <category term="React" />
    
    <category term="hook" />
    
  

  <summary>useMemo    성능 최적화를 위해 메모이제이션을 활용한다 즉, 특정 값이 변경될 때만 계산을 수행하여 불필요한 계산을 방지한다 이 훅은 계산 비용이 많이 드는 연산을 효율적으로 처리할 때 유용하다     사용법 const memoizedValue = useMemo(() =&amp;amp;gt; computeExpensiveValue(a, b), [a, b]);     여기서 computeExpensiveValue는 연산 비용이 많이 드는 함수이고, a와 b는 함수에 전달되는 의존성이다     주요 포인트    메모이제이션(Memoization)            useMemo는 연산 결과를 메모이제이션하여 특정 의존성 배열의 값이 변경되지 않는 한 이전 결과를 재사용한다           의존성 배열     ...</summary>

  </entry>

</feed>


